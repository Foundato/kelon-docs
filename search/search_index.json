{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kelon About Kelon is a policy enforcement point, that is wrapping the Open Policy Agent (OPA) by adding more functionality in terms of microservices. Motivation Let's say you have some services you would like to have authorization implemented into. With this challenge in mind there are basically two options: 1. Use code to secure your endpoints In case of REST-Services nearly every framework provides something like Guards or so 2. Use Kelon to secure your endpoints Just add some small code snippets to your service (like Request-Interceptors) and let Kelon handle the decision for you Conclusion It's obvious that the second option not only increases the speed at which you'll implement your service ( focusing only on the functionality ), but also grants much more security because all your policies are stored and enforced in one place (they can also be separately tested). This is basically the problem that the Open Policy Agent solves. The only problem is that it is very hard to integrate the OPA into a project because it needs the data which is needed to enforce policies to be stored inside it. This leads to work flows where you copy an abstraction of your entire database into OPA which is not only redundant, but also leads to synchronization issues. Getting Started Getting started with Kelon is as easy as following one of the How-To guides. Local deployment Example Setup Appstore example (Spring-Boot & Vue.js)","title":"Introduction"},{"location":"#kelon","text":"","title":"Kelon"},{"location":"#about","text":"Kelon is a policy enforcement point, that is wrapping the Open Policy Agent (OPA) by adding more functionality in terms of microservices.","title":"About"},{"location":"#motivation","text":"Let's say you have some services you would like to have authorization implemented into. With this challenge in mind there are basically two options:","title":"Motivation"},{"location":"#1-use-code-to-secure-your-endpoints","text":"In case of REST-Services nearly every framework provides something like Guards or so","title":"1. Use code to secure your endpoints"},{"location":"#2-use-kelon-to-secure-your-endpoints","text":"Just add some small code snippets to your service (like Request-Interceptors) and let Kelon handle the decision for you","title":"2. Use Kelon to secure your endpoints"},{"location":"#conclusion","text":"It's obvious that the second option not only increases the speed at which you'll implement your service ( focusing only on the functionality ), but also grants much more security because all your policies are stored and enforced in one place (they can also be separately tested). This is basically the problem that the Open Policy Agent solves. The only problem is that it is very hard to integrate the OPA into a project because it needs the data which is needed to enforce policies to be stored inside it. This leads to work flows where you copy an abstraction of your entire database into OPA which is not only redundant, but also leads to synchronization issues.","title":"Conclusion"},{"location":"#getting-started","text":"Getting started with Kelon is as easy as following one of the How-To guides. Local deployment Example Setup Appstore example (Spring-Boot & Vue.js)","title":"Getting Started"},{"location":"core/architecture/Components/","text":"Components The main goal of Kelons core design was to make extensible with ease while keeping it functional and efficient. Therefore the entire applicaiton logic was divided into small closely coupled components which can be easily replaced by self implemented plugins. Right now there is no mechanism for plugin loading, but as long as you implement Kelon's interfaces, you will be good to go when plugin-loading is available!","title":"Components"},{"location":"core/architecture/Components/#components","text":"The main goal of Kelons core design was to make extensible with ease while keeping it functional and efficient. Therefore the entire applicaiton logic was divided into small closely coupled components which can be easily replaced by self implemented plugins. Right now there is no mechanism for plugin loading, but as long as you implement Kelon's interfaces, you will be good to go when plugin-loading is available!","title":"Components"},{"location":"core/architecture/Policy-Translation/","text":"Policy Translation Kelon in a Nutshell Internally each request sent to Kelon goes through the same processing chain to finally become a translated native datastore-query. Following info graphic shows all configuration files and their interaction throughout this chain. Deconstructing the example To become a deep understanding of how Kelon works in action, we now deconstruct the entire internal process of Kelon while executing the example setup provided inside the repository. Therefore the following infographic shows an example query and its entire way through Kelon. (My)SQL The example for PostgreSQL is nearly the same (just swap 'mysql' with 'pg'). And now No-SQL When we run the example above against the MongoDB, there is also not much difference in each processing step. Only the generated output are now following native MongoDB-Query: users . find ({ \"$or\" : [ { \"name\" : \"Arnold\" , \"friend\" : \"Kevin\" } ] }) apps . find ({ \"$or\" : [ { \"id\" : 2 , \"stars\" : { \"$gt\" : 2 }, \"rights.right\" : \"OWNER\" , \"rights.user.name\" : \"Arnold\" }, { \"stars\" : 5 , \"id\" : 2 } ] })","title":"Policy Translation"},{"location":"core/architecture/Policy-Translation/#policy-translation","text":"","title":"Policy Translation"},{"location":"core/architecture/Policy-Translation/#kelon-in-a-nutshell","text":"Internally each request sent to Kelon goes through the same processing chain to finally become a translated native datastore-query. Following info graphic shows all configuration files and their interaction throughout this chain.","title":"Kelon in a Nutshell"},{"location":"core/architecture/Policy-Translation/#deconstructing-the-example","text":"To become a deep understanding of how Kelon works in action, we now deconstruct the entire internal process of Kelon while executing the example setup provided inside the repository. Therefore the following infographic shows an example query and its entire way through Kelon.","title":"Deconstructing the example"},{"location":"core/architecture/Policy-Translation/#mysql","text":"The example for PostgreSQL is nearly the same (just swap 'mysql' with 'pg').","title":"(My)SQL"},{"location":"core/architecture/Policy-Translation/#and-now-no-sql","text":"When we run the example above against the MongoDB, there is also not much difference in each processing step. Only the generated output are now following native MongoDB-Query: users . find ({ \"$or\" : [ { \"name\" : \"Arnold\" , \"friend\" : \"Kevin\" } ] }) apps . find ({ \"$or\" : [ { \"id\" : 2 , \"stars\" : { \"$gt\" : 2 }, \"rights.right\" : \"OWNER\" , \"rights.user.name\" : \"Arnold\" }, { \"stars\" : 5 , \"id\" : 2 } ] })","title":"And now No-SQL"},{"location":"core/architecture/Query-AST/","text":"Query AST Each Datastore has the task to translate a so called Query-AST into its native query language (which might become important to you as your datastore isn't supported by kelon yet). This means, that you have to Walk the entire Query-AST and translate it if you want to write your own Datastore-Plugin! It is worth mentioning that the method 'Walk' of every Node of the Query-AST walks the entire node's subtree (Visitor Pattern) buttom-up & left-right including the calling node as last visit.","title":"Query-AST"},{"location":"core/architecture/Query-AST/#query-ast","text":"Each Datastore has the task to translate a so called Query-AST into its native query language (which might become important to you as your datastore isn't supported by kelon yet). This means, that you have to Walk the entire Query-AST and translate it if you want to write your own Datastore-Plugin! It is worth mentioning that the method 'Walk' of every Node of the Query-AST walks the entire node's subtree (Visitor Pattern) buttom-up & left-right including the calling node as last visit.","title":"Query AST"},{"location":"core/extend/Write-Datastore-Plugin/","text":"","title":"Write a datasource plugin"},{"location":"core/extend/Write-Plugins/","text":"Write plugins","title":"Writing plugins"},{"location":"core/extend/Write-Plugins/#write-plugins","text":"","title":"Write plugins"},{"location":"core/integration/Kelon-Gloo/","text":"","title":"Kelon and Gloo"},{"location":"core/integration/Kelon-Istio/","text":"","title":"Kelon and Istio"},{"location":"core/integration/Services-And-Kelon/","text":"","title":"Services and Kelon"},{"location":"core/overview/Simple-Example/","text":"Example To get a first notion of what kelon does, we provide several example setups which all show a configuration of Kelon with three separate datastores (PostgreSQL, MySQL & MongoDB) in different environments. To demonstrate the ease of switching between datastores with kelon, all three datastores have the same data set. In the following tutorial, we will walk through all steps needed to get a project together with kelon up and running. Datamodel The datamodel is fairly simple but contains everything you will need in a more advanced setup (i.e. JOINS). MySQL & PostgreSQL: MongoDB: // Collection \"apps\" [ { id: <number>, name: <string>, stars: <number>, rights: [ { right: <string>, user: { id: <number>, name: <string>, age: <number>, friend: <string> } } ] } ] // Collection \"users\" [ { id: <number>, name: <string, age: <number>, friend: <string> } ] Example Dataset appstore.users id name age -friend 1 Arnold 73 John Connor 2 Kevin 21 Kevin 3 Anyone null Anyone appstore.apps id name stars 2 First App for everyone 1 2 Arnold's App 2 3 Famous App 5 appstore.app_rights app_id user_id right 2 1 OWNER Appstore example (Spring-Boot & Vue.js) Bored of this \"playground\" example? Then go ahead and checkout our Kelon-enabled fork of Daniel-Seifert's spring-vue-appstore which shows how to integrate kelon in a real-world szenario.","title":"Example"},{"location":"core/overview/Simple-Example/#example","text":"To get a first notion of what kelon does, we provide several example setups which all show a configuration of Kelon with three separate datastores (PostgreSQL, MySQL & MongoDB) in different environments. To demonstrate the ease of switching between datastores with kelon, all three datastores have the same data set. In the following tutorial, we will walk through all steps needed to get a project together with kelon up and running.","title":"Example"},{"location":"core/overview/Simple-Example/#datamodel","text":"The datamodel is fairly simple but contains everything you will need in a more advanced setup (i.e. JOINS). MySQL & PostgreSQL: MongoDB: // Collection \"apps\" [ { id: <number>, name: <string>, stars: <number>, rights: [ { right: <string>, user: { id: <number>, name: <string>, age: <number>, friend: <string> } } ] } ] // Collection \"users\" [ { id: <number>, name: <string, age: <number>, friend: <string> } ]","title":"Datamodel"},{"location":"core/overview/Simple-Example/#example-dataset","text":"","title":"Example Dataset"},{"location":"core/overview/Simple-Example/#appstoreusers","text":"id name age -friend 1 Arnold 73 John Connor 2 Kevin 21 Kevin 3 Anyone null Anyone","title":"appstore.users"},{"location":"core/overview/Simple-Example/#appstoreapps","text":"id name stars 2 First App for everyone 1 2 Arnold's App 2 3 Famous App 5","title":"appstore.apps"},{"location":"core/overview/Simple-Example/#appstoreapp_rights","text":"app_id user_id right 2 1 OWNER","title":"appstore.app_rights"},{"location":"core/overview/Simple-Example/#appstore-example-spring-boot-vuejs","text":"Bored of this \"playground\" example? Then go ahead and checkout our Kelon-enabled fork of Daniel-Seifert's spring-vue-appstore which shows how to integrate kelon in a real-world szenario.","title":"Appstore example (Spring-Boot &amp; Vue.js)"},{"location":"core/overview/example/Configure-Kelon/","text":"Configure Kelon With all the previous written policies in mind, we now have to tell Kelon how to find its way from incoming requests all the way down to . The configuration process of kelon has three basic parts: datastore.yml Configures datastore connections and their entity-schemas api.yml Mappings from incomin requests to a query fired against all policies inside a package opa.yml Configuration for the internally running Open Policy Agent datastore.yml In order to enable Kelon to connect to your datastores, you need to configure the connections as well as the internal entity-structure of all your datastores inside the datastore.yml config. # Datastores to connect to datastores : mysql : type : mysql connection : host : localhost # (mysql in case of the docker-compose example) port : 3306 database : appstore user : You password : SuperSecure pg : type : postgres connection : host : localhost # (postgres in case of the docker-compose example) port : 5432 database : appstore user : You password : SuperSecure sslmode : disable mongo : type : mongo connection : host : localhost # (mongo in case of the docker-compose example) port : 27017 database : appstore user : You password : SuperSecure # Entity-Schemas define the structure of the entities of one schema inside a datastore entity_schemas : mysql : appstore : entities : - name : users - name : app_rights - name : apps - name : app_tags - name : tags pg : appstore : entities : - name : users - name : app_rights - name : apps - name : app_tags - name : tags mongo : appstore : entities : - name : users - name : apps entities : - name : rights entities : - name : user alias : users While the definition of an entity_schema for a SQL-Datastore is straight forward (Just list all entities of each datastore), creating a entity_schema for a No-SQL-Datastore (like MongoDB) ist a bit more difficult. Here you need to map the Structure of your nested entities so that Kelon can use this nested structure to find the right query-path inside your No-SQL-Datastore when joining entities inside your policies. There is also the possibility to add more connection options for each datastore or use environment variables as yaml values. Please see the Operations Guide for more information. api.yml In the end all your services, which you want to secure with Kelon, receive client requests to a lot of different endpoints. To tell Kelon which policy it should use for which endpoint, you need to create the api.yml config. Inside this configuration you can define all your different APIs which will ultimately route a incoming request (Method, Path, Body) to a OPA-Package and Datastore. apis : # Route all requests starting with /api/mysql to MySQL - path-prefix : /api/mysql datastore : mysql mappings : - path : /apps/.* package : applications.mysql # Route all requests starting with /api/mongo to MongoDB - path-prefix : /api/mongo datastore : mongo mappings : - path : /apps/.* package : applications.mongo # All other requests are routed to PostgreSQL - path-prefix : /api/postgres datastore : pg mappings : - path : /apps/.* package : applications.pg call-operands A core feature of Kelon is to map the result of OPA's partial evaluated policies to native datastore queries. To keep the adoption to different datastore-platforms as flexible as possible, all builtin call operands from the OPA's Policy-Language are mapped via mappings-files which are located in the call-operands directory. Each mapping file is used for one datastory type and is therefore named with the pattern call-operands/{datastore-type}.yml . call-operands/mysql.yml & call-operands/postgres.yml Each internal function essentially consists of a operator (op) and its arguments. To map this function to a datastore-native query function, you need to define the original functions-operator and the amount of expected arguments as well as the resulting mapping inside the native query. call-operands : # Mathematical operands # ... # Relational operands - op : eq args : 2 mapping : \"$0 = $1\" - op : equal args : 2 mapping : \"$0 = $1\" - op : neq args : 2 mapping : \"$0 != $1\" - op : lt args : 2 mapping : \"$0 < $1\" - op : gt args : 2 mapping : \"$0 > $1\" - op : lte args : 2 mapping : \"$0 <= $1\" - op : gte args : 2 mapping : \"$0 >= $1\" # Mathematical Functions # ... Let's take the mapping gte from above. The builtin call gte(a, b) will be mapped to a >= b inside your native SQL-Query. call-operands/mongo.yml call-operands : # Relational operands - op : eq args : 2 mapping : \"$0: $1\" - op : equal args : 2 mapping : \"$0: $1\" - op : neq args : 2 mapping : \"$0: { \\\"$ne\\\": $1 }\" - op : lt args : 2 mapping : \"$0: { \\\"$lt\\\": $1 }\" - op : gt args : 2 mapping : \"$0: { \\\"$gt\\\": $1 }\" - op : lte args : 2 mapping : \"$0: { \\\"$lte\\\": $1 }\" - op : gte args : 2 mapping : \"$0: { \\\"$gte\\\": $1 }\" opa.yml Becaues Kelon is just a wrapper around the Open Policy Agent, you can also configure the internally used OPA itself. labels : app : Kelon region : europe-west3 environment : development decision_logs : console : true reporting : min_delay_seconds : 300 max_delay_seconds : 600 default_decision : /http/authz/allow","title":"Configure Kelon"},{"location":"core/overview/example/Configure-Kelon/#configure-kelon","text":"With all the previous written policies in mind, we now have to tell Kelon how to find its way from incoming requests all the way down to . The configuration process of kelon has three basic parts: datastore.yml Configures datastore connections and their entity-schemas api.yml Mappings from incomin requests to a query fired against all policies inside a package opa.yml Configuration for the internally running Open Policy Agent","title":"Configure Kelon"},{"location":"core/overview/example/Configure-Kelon/#datastoreyml","text":"In order to enable Kelon to connect to your datastores, you need to configure the connections as well as the internal entity-structure of all your datastores inside the datastore.yml config. # Datastores to connect to datastores : mysql : type : mysql connection : host : localhost # (mysql in case of the docker-compose example) port : 3306 database : appstore user : You password : SuperSecure pg : type : postgres connection : host : localhost # (postgres in case of the docker-compose example) port : 5432 database : appstore user : You password : SuperSecure sslmode : disable mongo : type : mongo connection : host : localhost # (mongo in case of the docker-compose example) port : 27017 database : appstore user : You password : SuperSecure # Entity-Schemas define the structure of the entities of one schema inside a datastore entity_schemas : mysql : appstore : entities : - name : users - name : app_rights - name : apps - name : app_tags - name : tags pg : appstore : entities : - name : users - name : app_rights - name : apps - name : app_tags - name : tags mongo : appstore : entities : - name : users - name : apps entities : - name : rights entities : - name : user alias : users While the definition of an entity_schema for a SQL-Datastore is straight forward (Just list all entities of each datastore), creating a entity_schema for a No-SQL-Datastore (like MongoDB) ist a bit more difficult. Here you need to map the Structure of your nested entities so that Kelon can use this nested structure to find the right query-path inside your No-SQL-Datastore when joining entities inside your policies. There is also the possibility to add more connection options for each datastore or use environment variables as yaml values. Please see the Operations Guide for more information.","title":"datastore.yml"},{"location":"core/overview/example/Configure-Kelon/#apiyml","text":"In the end all your services, which you want to secure with Kelon, receive client requests to a lot of different endpoints. To tell Kelon which policy it should use for which endpoint, you need to create the api.yml config. Inside this configuration you can define all your different APIs which will ultimately route a incoming request (Method, Path, Body) to a OPA-Package and Datastore. apis : # Route all requests starting with /api/mysql to MySQL - path-prefix : /api/mysql datastore : mysql mappings : - path : /apps/.* package : applications.mysql # Route all requests starting with /api/mongo to MongoDB - path-prefix : /api/mongo datastore : mongo mappings : - path : /apps/.* package : applications.mongo # All other requests are routed to PostgreSQL - path-prefix : /api/postgres datastore : pg mappings : - path : /apps/.* package : applications.pg","title":"api.yml"},{"location":"core/overview/example/Configure-Kelon/#call-operands","text":"A core feature of Kelon is to map the result of OPA's partial evaluated policies to native datastore queries. To keep the adoption to different datastore-platforms as flexible as possible, all builtin call operands from the OPA's Policy-Language are mapped via mappings-files which are located in the call-operands directory. Each mapping file is used for one datastory type and is therefore named with the pattern call-operands/{datastore-type}.yml .","title":"call-operands"},{"location":"core/overview/example/Configure-Kelon/#call-operandsmysqlyml-call-operandspostgresyml","text":"Each internal function essentially consists of a operator (op) and its arguments. To map this function to a datastore-native query function, you need to define the original functions-operator and the amount of expected arguments as well as the resulting mapping inside the native query. call-operands : # Mathematical operands # ... # Relational operands - op : eq args : 2 mapping : \"$0 = $1\" - op : equal args : 2 mapping : \"$0 = $1\" - op : neq args : 2 mapping : \"$0 != $1\" - op : lt args : 2 mapping : \"$0 < $1\" - op : gt args : 2 mapping : \"$0 > $1\" - op : lte args : 2 mapping : \"$0 <= $1\" - op : gte args : 2 mapping : \"$0 >= $1\" # Mathematical Functions # ... Let's take the mapping gte from above. The builtin call gte(a, b) will be mapped to a >= b inside your native SQL-Query.","title":"call-operands/mysql.yml &amp; call-operands/postgres.yml"},{"location":"core/overview/example/Configure-Kelon/#call-operandsmongoyml","text":"call-operands : # Relational operands - op : eq args : 2 mapping : \"$0: $1\" - op : equal args : 2 mapping : \"$0: $1\" - op : neq args : 2 mapping : \"$0: { \\\"$ne\\\": $1 }\" - op : lt args : 2 mapping : \"$0: { \\\"$lt\\\": $1 }\" - op : gt args : 2 mapping : \"$0: { \\\"$gt\\\": $1 }\" - op : lte args : 2 mapping : \"$0: { \\\"$lte\\\": $1 }\" - op : gte args : 2 mapping : \"$0: { \\\"$gte\\\": $1 }\"","title":"call-operands/mongo.yml"},{"location":"core/overview/example/Configure-Kelon/#opayml","text":"Becaues Kelon is just a wrapper around the Open Policy Agent, you can also configure the internally used OPA itself. labels : app : Kelon region : europe-west3 environment : development decision_logs : console : true reporting : min_delay_seconds : 300 max_delay_seconds : 600 default_decision : /http/authz/allow","title":"opa.yml"},{"location":"core/overview/example/Create-Policies/","text":"Create Policies In order to enable Kelon to make decisions on incoming requests, you have to write policies in OPA's own Policy-Language which you can put in different Rego-Files. To keep your policies organized, you can define a package per Rego-File which is also the central way to address all policies inside this package. As a result of that you should keep your package-names clean and in some way connected to the API you want to secure with Kelon. For this example we want to create four simple policies which show all basic capabilities of kelon: Users with right 'OWNER' on app can access it always Endpoint: GET /api/{datastore-alias}/apps/:app_id All apps with 5 stars are public Endpoint: GET /api/{datastore-alias}/apps/:app_id The first app is public Endpoint: GET /api/{datastore-alias}/apps/:app_id All users that are a friends of Kevin are allowed see everything Endpoint: GET /api/{datastore-alias}/* SQL policies/mysql_applications.rego The file policies/pg_applications.rego has almost the same content. The only difference is that each \"mysql\" is replaced by a \"pg\" (which only occurs, because of this simple szenario). package applications.mysql # Deny all by default allow = false # Path: GET /api/mysql/apps/:app_id # Users with right 'OWNER' on app can access it always allow = true { some appId, u, r input.method == \"GET\" input.path = [\"api\", \"mysql\", \"apps\", appId] # Join data.mysql.users[u].id == data.mysql.app_rights[r].user_id # Where u.name == input.user r.right == \"OWNER\" r.app_id == appId } # Path: GET /api/mysql/apps/:app_id # All apps with 5 stars are public allow = true { some app, appId input.method == \"GET\" input.path = [\"api\", \"mysql\", \"apps\", appId] data.mysql.apps[app].id == appId app.stars == 5 } # Path: GET /api/mysql/apps/:app_id # The first app is public allow = true { input.method == \"GET\" input.path == [\"api\", \"mysql\", \"apps\", \"1\"] } # Path: GET <any> # All users that are a friends of Kevin are allowed see everything allow = true { some user input.method == \"GET\" # Query data.mysql.users[user].name == input.user user.friend == \"Kevin\" } With a closer look at the first policy in the above Rego you will notice, that the data inside the tables of your datastore can be 'magically' accessed inside Regos with the following Syntax: data.{datastore-alias}.{entity}.{column} Additianally the join between the table users and app_rights on the condition users.id == app_rights.user_id is done with the statements data.mysql.users[u].id == data.mysql.app_rights[r].user_id u.name == input.user r.right == \"OWNER\" r.app_id == appId # SELECT count(*) FROM users # INNER JOIN app_rights # ON users.id = app_rights.user_id # WHERE users.name = {input.user} # AND app_rights.right = 'OWNER' # AND app_rights.app_id = {appId} No-SQL policies/mongo_applications.rego Writing policies for No-SQL datastores is nearly the same as writing them for SQL-Datastores. You can just write a join (as if it was for a SQL-Datastore) which is translated by kelon using your configured entity_schema The only difference to writing policies in comparison to SQL-Datastores is: The first entity of your policy must be the the collection (in case of MongoDB) you want to address The Join-Condition is ignored (You still have to add any condition for now...) package applications.mongo # Deny all by default allow = false # Path: GET /api/mongo/apps/:app_id # Users with right 'OWNER' on app can access it always allow = true { input.method == \"GET\" input.path = [\"api\", \"mongo\", \"apps\", appId] # This query fires against collection -> apps data.mongo.apps[app].id == appId # Nest elements data.mongo.rights[right].id == app.id data.mongo.users[user].id == right.id # Query root app.stars > 2 # Query nested right.right == \"OWNER\" user.name == input.user } ... Common policy patterns Following examples show basic policy patterns which you can use to write your policies Join single entity # Datastore-Alias: mysql # Table-Join: users -> app_rights data.mysql.users[user].id == data.mysql.app_rights[appRight].user_id Join multiple entities # Datastore-Alias: mysql # Table-Join: users -> app_rights -> apps data.mysql.users[user].id == data.mysql.app_rights[appRight].user_id data.mysql.apps[app].id == appRights.app_id Self-Join Self-Join is currently not supported by Kelon!","title":"Create Policies"},{"location":"core/overview/example/Create-Policies/#create-policies","text":"In order to enable Kelon to make decisions on incoming requests, you have to write policies in OPA's own Policy-Language which you can put in different Rego-Files. To keep your policies organized, you can define a package per Rego-File which is also the central way to address all policies inside this package. As a result of that you should keep your package-names clean and in some way connected to the API you want to secure with Kelon. For this example we want to create four simple policies which show all basic capabilities of kelon: Users with right 'OWNER' on app can access it always Endpoint: GET /api/{datastore-alias}/apps/:app_id All apps with 5 stars are public Endpoint: GET /api/{datastore-alias}/apps/:app_id The first app is public Endpoint: GET /api/{datastore-alias}/apps/:app_id All users that are a friends of Kevin are allowed see everything Endpoint: GET /api/{datastore-alias}/*","title":"Create Policies"},{"location":"core/overview/example/Create-Policies/#sql","text":"","title":"SQL"},{"location":"core/overview/example/Create-Policies/#policiesmysql_applicationsrego","text":"The file policies/pg_applications.rego has almost the same content. The only difference is that each \"mysql\" is replaced by a \"pg\" (which only occurs, because of this simple szenario). package applications.mysql # Deny all by default allow = false # Path: GET /api/mysql/apps/:app_id # Users with right 'OWNER' on app can access it always allow = true { some appId, u, r input.method == \"GET\" input.path = [\"api\", \"mysql\", \"apps\", appId] # Join data.mysql.users[u].id == data.mysql.app_rights[r].user_id # Where u.name == input.user r.right == \"OWNER\" r.app_id == appId } # Path: GET /api/mysql/apps/:app_id # All apps with 5 stars are public allow = true { some app, appId input.method == \"GET\" input.path = [\"api\", \"mysql\", \"apps\", appId] data.mysql.apps[app].id == appId app.stars == 5 } # Path: GET /api/mysql/apps/:app_id # The first app is public allow = true { input.method == \"GET\" input.path == [\"api\", \"mysql\", \"apps\", \"1\"] } # Path: GET <any> # All users that are a friends of Kevin are allowed see everything allow = true { some user input.method == \"GET\" # Query data.mysql.users[user].name == input.user user.friend == \"Kevin\" } With a closer look at the first policy in the above Rego you will notice, that the data inside the tables of your datastore can be 'magically' accessed inside Regos with the following Syntax: data.{datastore-alias}.{entity}.{column} Additianally the join between the table users and app_rights on the condition users.id == app_rights.user_id is done with the statements data.mysql.users[u].id == data.mysql.app_rights[r].user_id u.name == input.user r.right == \"OWNER\" r.app_id == appId # SELECT count(*) FROM users # INNER JOIN app_rights # ON users.id = app_rights.user_id # WHERE users.name = {input.user} # AND app_rights.right = 'OWNER' # AND app_rights.app_id = {appId}","title":"policies/mysql_applications.rego"},{"location":"core/overview/example/Create-Policies/#no-sql","text":"","title":"No-SQL"},{"location":"core/overview/example/Create-Policies/#policiesmongo_applicationsrego","text":"Writing policies for No-SQL datastores is nearly the same as writing them for SQL-Datastores. You can just write a join (as if it was for a SQL-Datastore) which is translated by kelon using your configured entity_schema The only difference to writing policies in comparison to SQL-Datastores is: The first entity of your policy must be the the collection (in case of MongoDB) you want to address The Join-Condition is ignored (You still have to add any condition for now...) package applications.mongo # Deny all by default allow = false # Path: GET /api/mongo/apps/:app_id # Users with right 'OWNER' on app can access it always allow = true { input.method == \"GET\" input.path = [\"api\", \"mongo\", \"apps\", appId] # This query fires against collection -> apps data.mongo.apps[app].id == appId # Nest elements data.mongo.rights[right].id == app.id data.mongo.users[user].id == right.id # Query root app.stars > 2 # Query nested right.right == \"OWNER\" user.name == input.user } ...","title":"policies/mongo_applications.rego"},{"location":"core/overview/example/Create-Policies/#common-policy-patterns","text":"Following examples show basic policy patterns which you can use to write your policies","title":"Common policy patterns"},{"location":"core/overview/example/Create-Policies/#join-single-entity","text":"# Datastore-Alias: mysql # Table-Join: users -> app_rights data.mysql.users[user].id == data.mysql.app_rights[appRight].user_id","title":"Join single entity"},{"location":"core/overview/example/Create-Policies/#join-multiple-entities","text":"# Datastore-Alias: mysql # Table-Join: users -> app_rights -> apps data.mysql.users[user].id == data.mysql.app_rights[appRight].user_id data.mysql.apps[app].id == appRights.app_id","title":"Join multiple entities"},{"location":"core/overview/example/Create-Policies/#self-join","text":"Self-Join is currently not supported by Kelon!","title":"Self-Join"},{"location":"core/overview/example/Run-Example/","text":"Run the example Install kelon (not needed if you want to use the docker-comopose file from the example) From source # Clone the repository $ git clone git@github.com:Foundato/kelon.git # Build the container $ docker build . -t kelon:latest # Or install kelon on your local machine $ go mod download $ go build -o ./kelon ./cmd/kelon Docker image $ docker pull kelonio/kelon Start the environment The entire example environment can be started with the provided docker-compose in the project's root directory with following command $ docker-compose up -d This will start following components: Kelon Port: 8181 MySQL Port: 3306 PostgreSQL Port: 5432 MongoDB Port: 27017-27019 After all containers are built and up, you can verify that everything is up by performing a valid request: to PostgreSQL $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } to MySQL $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/mysql/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } to MongoDB $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/mongo/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } Play around You now have a complete setup of Kelon which you can use to play around. You can i.e. try to access an app you shouldn't be allowed to: $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/2\", \"user\": \"Anyone\"}}' > { \"result\" :false } Or access an app with 5 stars (which the user 'Anyone' is allowed to): $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/3\", \"user\": \"Anyone\"}}' > { \"result\" :true } There is also a POSTMAN-COLLECTION in the example directory which contains a bunch of queries agains all three datasources (PostgreSQL, MySQL, MongoDB). Feel free to play around with the existing regos and databases to get a feeling of how to write policies and configure Kelon. Good to know Due to Kelon's hot reloading of policies , you can edit the policies which are mounted into the Docker-Container and directly see the result of your work within seconds. Please also check the Container-Logs. If you make any mistake while writing your policies, Kelon will let you know. Clean up After you are done, just stop the entire setup by running: $ docker-compose down","title":"Run the example"},{"location":"core/overview/example/Run-Example/#run-the-example","text":"","title":"Run the example"},{"location":"core/overview/example/Run-Example/#install-kelon","text":"(not needed if you want to use the docker-comopose file from the example)","title":"Install kelon"},{"location":"core/overview/example/Run-Example/#from-source","text":"# Clone the repository $ git clone git@github.com:Foundato/kelon.git # Build the container $ docker build . -t kelon:latest # Or install kelon on your local machine $ go mod download $ go build -o ./kelon ./cmd/kelon","title":"From source"},{"location":"core/overview/example/Run-Example/#docker-image","text":"$ docker pull kelonio/kelon","title":"Docker image"},{"location":"core/overview/example/Run-Example/#start-the-environment","text":"The entire example environment can be started with the provided docker-compose in the project's root directory with following command $ docker-compose up -d This will start following components: Kelon Port: 8181 MySQL Port: 3306 PostgreSQL Port: 5432 MongoDB Port: 27017-27019 After all containers are built and up, you can verify that everything is up by performing a valid request: to PostgreSQL $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } to MySQL $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/mysql/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } to MongoDB $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/mongo/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true }","title":"Start the environment"},{"location":"core/overview/example/Run-Example/#play-around","text":"You now have a complete setup of Kelon which you can use to play around. You can i.e. try to access an app you shouldn't be allowed to: $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/2\", \"user\": \"Anyone\"}}' > { \"result\" :false } Or access an app with 5 stars (which the user 'Anyone' is allowed to): $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/3\", \"user\": \"Anyone\"}}' > { \"result\" :true } There is also a POSTMAN-COLLECTION in the example directory which contains a bunch of queries agains all three datasources (PostgreSQL, MySQL, MongoDB). Feel free to play around with the existing regos and databases to get a feeling of how to write policies and configure Kelon.","title":"Play around"},{"location":"core/overview/example/Run-Example/#good-to-know","text":"Due to Kelon's hot reloading of policies , you can edit the policies which are mounted into the Docker-Container and directly see the result of your work within seconds. Please also check the Container-Logs. If you make any mistake while writing your policies, Kelon will let you know.","title":"Good to know"},{"location":"core/overview/example/Run-Example/#clean-up","text":"After you are done, just stop the entire setup by running: $ docker-compose down","title":"Clean up"},{"location":"core/philosophy/What-Is-A-Policy/","text":"What is a policy","title":"What is a Policy"},{"location":"core/philosophy/What-Is-A-Policy/#what-is-a-policy","text":"","title":"What is a policy"},{"location":"core/philosophy/Why-External-Policy-Enforcement/","text":"Why external policy enforcement In modern software development where terms like 'Microservices' and 'Agile' rule almost every Kick-Off-Meeting, the need of developing large systems while keeping the teams small and language independent gets more and more important. While the idiom 'Divide And Conquer' works for the splitting of domains and development-teams, splitting up central processes like authorization won't work with this approach. Implementing authorization policies into each microservice will quickly end in a large pile of different services all implementing (or maybe not implementing) parts of the previously defined business rules. This may become even more difficult if you want to enforce global policies throughout your entire system. Therefore external-policy-enforcement and with it the Open Policy Agent (OPA) has arisen in the Open-Source Community. The OPA-Way of enforcing policies is by implementing and also testing all your business-rules in one single component (The Open Policy Agent) and make your services query it for permission on any incoming user request. As a result your services become dumb (in terms of authorization) which makes them easier to implement. On the other hand the enforcement of your policies becomes much more transparent and easier to test and review because all your policies are stored in one place.","title":"Why external Policy Enforcement"},{"location":"core/philosophy/Why-External-Policy-Enforcement/#why-external-policy-enforcement","text":"In modern software development where terms like 'Microservices' and 'Agile' rule almost every Kick-Off-Meeting, the need of developing large systems while keeping the teams small and language independent gets more and more important. While the idiom 'Divide And Conquer' works for the splitting of domains and development-teams, splitting up central processes like authorization won't work with this approach. Implementing authorization policies into each microservice will quickly end in a large pile of different services all implementing (or maybe not implementing) parts of the previously defined business rules. This may become even more difficult if you want to enforce global policies throughout your entire system. Therefore external-policy-enforcement and with it the Open Policy Agent (OPA) has arisen in the Open-Source Community. The OPA-Way of enforcing policies is by implementing and also testing all your business-rules in one single component (The Open Policy Agent) and make your services query it for permission on any incoming user request. As a result your services become dumb (in terms of authorization) which makes them easier to implement. On the other hand the enforcement of your policies becomes much more transparent and easier to test and review because all your policies are stored in one place.","title":"Why external policy enforcement"},{"location":"kelon/Initial-Exploration/","text":"Introduction To get a better understanding of how kelon is built, have a look at following infographics to get a better understanding of the surrounding environment of Kelon. External interfaces Request flow Interface usage exploration In order to intercept each request in your backend and send it to Kelon, you have to implement some kind of middleware in your backend. All big backend-frameworks contain middleware-APIs which help you to write this interception with only a view lines of code. Following interface usage exploration lists a view common frameworks and their authorization-middleware components. Note the two different approaches of implementing the authorization-middleware (either by having one interceptor which sends all incoming requests to kelon or multiple interceptors). We strongly recommend you to only use one interceptor!","title":"Introduction"},{"location":"kelon/Initial-Exploration/#introduction","text":"To get a better understanding of how kelon is built, have a look at following infographics to get a better understanding of the surrounding environment of Kelon.","title":"Introduction"},{"location":"kelon/Initial-Exploration/#external-interfaces","text":"","title":"External interfaces"},{"location":"kelon/Initial-Exploration/#request-flow","text":"","title":"Request flow"},{"location":"kelon/Initial-Exploration/#interface-usage-exploration","text":"In order to intercept each request in your backend and send it to Kelon, you have to implement some kind of middleware in your backend. All big backend-frameworks contain middleware-APIs which help you to write this interception with only a view lines of code. Following interface usage exploration lists a view common frameworks and their authorization-middleware components. Note the two different approaches of implementing the authorization-middleware (either by having one interceptor which sends all incoming requests to kelon or multiple interceptors). We strongly recommend you to only use one interceptor!","title":"Interface usage exploration"},{"location":"kelon/architecture/Request-Mapping/","text":"Request mapping Each incoming request to the backend has to be intercepted and wrapped in a JSON-object called \"input\". This object has to contain all important information about the incoming request like 'method', 'path' and i.e. 'authorization'. Kelon takes the input-object, adds more information to it and compiles it with the Open Policy Agent. This means you also have access to i.e. Query-Parameters a client sent to your backend inside your Regos!","title":"Request mapping"},{"location":"kelon/architecture/Request-Mapping/#request-mapping","text":"Each incoming request to the backend has to be intercepted and wrapped in a JSON-object called \"input\". This object has to contain all important information about the incoming request like 'method', 'path' and i.e. 'authorization'. Kelon takes the input-object, adds more information to it and compiles it with the Open Policy Agent. This means you also have access to i.e. Query-Parameters a client sent to your backend inside your Regos!","title":"Request mapping"},{"location":"operations/APIs/","text":"APIs","title":"APIs"},{"location":"operations/APIs/#apis","text":"","title":"APIs"},{"location":"operations/Configuration/","text":"Configuration Kelon (CLI) Kelon already comes with a CLI. Just type kelon --help after you installed it. usage: kelon [<flags>] <command> [<args> ...] Kelon policy enforcer. Flags: -h, --help Show context-sensitive help (also try --help-long and --help-man). -o, --opa-conf=./opa.yml Path to the OPA configuration yaml. -r, --rego-dir=./policies Dir containing .rego files which will be loaded into OPA. --path-prefix=\"/v1\" Prefix which is used to proxy OPA's Data-API. -p, --port=8181 Port on which the proxy endpoint is served. --envoy-port=ENVOY-PORT Also start Envoy GRPC-Proxy on specified port so integrate kelon with Istio. --envoy-dry-run Enable/Disable the dry run feature of the envoy-proxy. --envoy-reflection Enable/Disable the reflection feature of the envoy-proxy. --respond-with-status-code Communicate Decision via status code 200 (ALLOW) or 403 (DENY). --istio-port=ISTIO-PORT Also start Istio Mixer Out of Tree Adapter on specified port so integrate kelon with Istio. -d, --datastore-conf=./datastore.yml Path to the datastore configuration yaml. -a, --api-conf=./api.yml Path to the api configuration yaml. --config-watcher-path=./policies Path where the config watcher should listen for changes. --version Show application version. Commands: help [<command>...] Show help. start Start kelon in production mode. debug Enable debug mode. In addition to that Kelon provides the possibility to be configured via environment variables. This may be handy if you want to run it inside a container. Flag Short Environment Default Type --opa-conf -o OPA_CONF ./opa.yml Existing File --rego-dir -r REGO_DIR ./policies Existing Dir --path-prefix PATH_PREFIX /v1 String --port -p PORT 8181 Number --envoy-port ENVOY_PORT Number --istio-port ISTIO_PORT Number --envoy-dry-run ENVOY_DRY_RUN false Boolean --envoy-reflection ENVOY_REFLECTION false Boolean --datastore-conf -d DATASTORE_CONF ./datastore.yml Existing File --api-conf -a API_CONF ./api.yml Existing File --config-watcher-path CONFIG_WATCHER_PATH ./policies Existing Dir --respond-with-status-code RESPOND_WITH_STATUS_CODE false bool datastore.yml The datastore.yml defines all available datastores and their entities. # List of all datastores which kelon should be able to connect to # Each datastore has to have an entity schema configured! datastores : # Datastore's alias (it will be used throughout all your policies). mysql : # Datastore type # Kelon supports [mysql, postgres, mongo] [ type : <string> ] # Properties that are needed to connect to the datastore connection : # Hostname or IP of the database [ host : <string> ] # Port under which the database is available [ port : <int> ] # Name of the database to connect to # Many database servers run multiple databases. # In this case create one datastore for each database [ database : <string> ] # The user which is used for the database connection [ user : <string> ] # The password of the user [ password : <string> ] # Connection options for the database connection # To get all available options for your database, see section \"Connection options\" below [ <option> : <string> ] # Entity-Schemas define the entities of one schema inside a datastore. # An entity_schema has several purposes: # => Help kelon to detect misspellings in regos # => Create entity-aliases for complex table-names # => Define the structure of nested entities (Just for No-SQL DBs) entity_schemas : # Datastore's alias # This example shows how each SQL-Datastore should be configured. mysql : # Schema name # Kelon automatically adds the schema name to entities # This means that 'data.mysql.users' inside a rego will be translated # to 'appstore.users' in the resulting SQL-Statement. # # !!! The entities inside all schemas of one Datastore have to be disjunct !!! # Otherwise kelon will fail on startup appstore : # List of all entities of schema 'appstore' entities : # Entity with the name inside the datastore - [ name : <string> ] # And an optional alias (used inside regos) [ alias : <string> | optional ] # This example shows how each No-SQL-Datastore should be configured. mongo : # Schema name # Because No-SQL-Datastores don't have concept for schemas, # Kelon ignores the schema name for i.e. a MongoDB. # # !!! The entities inside all schemas of one Datastore have to be disjunct !!! # Otherwise kelon will fail on startup appstore : # List of all entities (in case of MongoDB each entity is a collection) entities : # Collection with it's name inside the datastore - [ name : <string> ] # Collection's optinal alias (used inside regos) [ alias : <string> | optional ] # Nested entities (Only supported for No-SQL-Datastores) # The depth of nesting entities is unlimited. # It makes no difference if the nested entities are arrays or objects entities : # Name of nested entity - [ name : <string> ] # Collection's optinal alias (used inside regos) [ alias : <string> | optional ] Connection options Kelon supports different databases (PostgreSQL, MySQL and MongoDB) each of them having different connection options. To keep the configuration of connection options as simple as possible, Kelon just passes all key-value-pairs of each the datastore connection (despite the dedicated ones like i.e. username, host, port, etc.) directly to the used database adapter. Following table should help to lookup all available options for each supported database: Database Used driver Options PostgreSQL github.com/lib/pq Go Docs, Connection String Parameters MySQL github.com/go-sql-driver/mysql Go Docs, DSN Parameters MongoDB go.mongodb.org/mongo-driver/mongo Mongo-Docs, Connection options Injecting environment variables Each value inside the datastore.yml file can be replaced with a string follwing the pattern ${<environment variable>} which is replaced with the value of the environment variable at startup. call-operands/{datastore-type}.yml Open Policy Agent has builtin call operands which may not be the same as the ones of each datastore. Therefore each datastore-type has to have a mapping-file inside the folder 'call-operands'. The name of each file inside this directory has to match the type of the datastore. # Call operands map OPA's functions to datastore-native ones. # You find more advanced files in directory /call-operands call-operands : # Operand name inside OPA's context - [ op : <string> ] # Number of arguments the function call should take # Used for validation [ args : <int> ] # Mapping which mappes the OPA-native call to a Datastore-native call. # This is done by defining a pattern where all occurences of $<arg-pos> # are replaced with the original argument at position <arg-pos> (zero based). [ mapping : <string> ] api.yml The datastore.yml contains all necessary configuration kelon needs to map incoming api-requests to OPA-Queries executed inside datastores. # Mappings for the APIs that your services expose apis : # API-Collection # Each collection can have a path prefix which is prepended to every API-Mapping # inside the collection. - [ path-prefix : <URL|string> ] # All rego-queries mapped by this API-collection will include # this datastore-alias as unknown. # This means that the regos this collection targets can contain # something like 'data.<datastore-alias>.<entity>.<attribute>' [ datastore : <datastore-alias|string> ] # Path-Mappings for incoming paths # (the most specific mapping is picked in case of multiple mappings) mappings : # Path-Mapping # Each mapping has to specify a path (regex) and a package which is used # by kelon to generate the target package of an mapped query. - [ path : <regex|string> ] # OPA's target package of this Path-Mapping [ package : <string> ] # HTTP-Methods this path should map (optional) # If no methods are specified, kellon will match [GET,PUT,POST,DELETE,PATCH] methods : - [ <string> ... ] opa.yml Internally used by Open Policy Agent. Klick here for more information. labels : app : Kelon region : europe-west3 environment : development decision_logs : console : true reporting : min_delay_seconds : 300 max_delay_seconds : 600 default_decision : /http/authz/allow","title":"Configuration"},{"location":"operations/Configuration/#configuration","text":"","title":"Configuration"},{"location":"operations/Configuration/#kelon-cli","text":"Kelon already comes with a CLI. Just type kelon --help after you installed it. usage: kelon [<flags>] <command> [<args> ...] Kelon policy enforcer. Flags: -h, --help Show context-sensitive help (also try --help-long and --help-man). -o, --opa-conf=./opa.yml Path to the OPA configuration yaml. -r, --rego-dir=./policies Dir containing .rego files which will be loaded into OPA. --path-prefix=\"/v1\" Prefix which is used to proxy OPA's Data-API. -p, --port=8181 Port on which the proxy endpoint is served. --envoy-port=ENVOY-PORT Also start Envoy GRPC-Proxy on specified port so integrate kelon with Istio. --envoy-dry-run Enable/Disable the dry run feature of the envoy-proxy. --envoy-reflection Enable/Disable the reflection feature of the envoy-proxy. --respond-with-status-code Communicate Decision via status code 200 (ALLOW) or 403 (DENY). --istio-port=ISTIO-PORT Also start Istio Mixer Out of Tree Adapter on specified port so integrate kelon with Istio. -d, --datastore-conf=./datastore.yml Path to the datastore configuration yaml. -a, --api-conf=./api.yml Path to the api configuration yaml. --config-watcher-path=./policies Path where the config watcher should listen for changes. --version Show application version. Commands: help [<command>...] Show help. start Start kelon in production mode. debug Enable debug mode. In addition to that Kelon provides the possibility to be configured via environment variables. This may be handy if you want to run it inside a container. Flag Short Environment Default Type --opa-conf -o OPA_CONF ./opa.yml Existing File --rego-dir -r REGO_DIR ./policies Existing Dir --path-prefix PATH_PREFIX /v1 String --port -p PORT 8181 Number --envoy-port ENVOY_PORT Number --istio-port ISTIO_PORT Number --envoy-dry-run ENVOY_DRY_RUN false Boolean --envoy-reflection ENVOY_REFLECTION false Boolean --datastore-conf -d DATASTORE_CONF ./datastore.yml Existing File --api-conf -a API_CONF ./api.yml Existing File --config-watcher-path CONFIG_WATCHER_PATH ./policies Existing Dir --respond-with-status-code RESPOND_WITH_STATUS_CODE false bool","title":"Kelon (CLI)"},{"location":"operations/Configuration/#datastoreyml","text":"The datastore.yml defines all available datastores and their entities. # List of all datastores which kelon should be able to connect to # Each datastore has to have an entity schema configured! datastores : # Datastore's alias (it will be used throughout all your policies). mysql : # Datastore type # Kelon supports [mysql, postgres, mongo] [ type : <string> ] # Properties that are needed to connect to the datastore connection : # Hostname or IP of the database [ host : <string> ] # Port under which the database is available [ port : <int> ] # Name of the database to connect to # Many database servers run multiple databases. # In this case create one datastore for each database [ database : <string> ] # The user which is used for the database connection [ user : <string> ] # The password of the user [ password : <string> ] # Connection options for the database connection # To get all available options for your database, see section \"Connection options\" below [ <option> : <string> ] # Entity-Schemas define the entities of one schema inside a datastore. # An entity_schema has several purposes: # => Help kelon to detect misspellings in regos # => Create entity-aliases for complex table-names # => Define the structure of nested entities (Just for No-SQL DBs) entity_schemas : # Datastore's alias # This example shows how each SQL-Datastore should be configured. mysql : # Schema name # Kelon automatically adds the schema name to entities # This means that 'data.mysql.users' inside a rego will be translated # to 'appstore.users' in the resulting SQL-Statement. # # !!! The entities inside all schemas of one Datastore have to be disjunct !!! # Otherwise kelon will fail on startup appstore : # List of all entities of schema 'appstore' entities : # Entity with the name inside the datastore - [ name : <string> ] # And an optional alias (used inside regos) [ alias : <string> | optional ] # This example shows how each No-SQL-Datastore should be configured. mongo : # Schema name # Because No-SQL-Datastores don't have concept for schemas, # Kelon ignores the schema name for i.e. a MongoDB. # # !!! The entities inside all schemas of one Datastore have to be disjunct !!! # Otherwise kelon will fail on startup appstore : # List of all entities (in case of MongoDB each entity is a collection) entities : # Collection with it's name inside the datastore - [ name : <string> ] # Collection's optinal alias (used inside regos) [ alias : <string> | optional ] # Nested entities (Only supported for No-SQL-Datastores) # The depth of nesting entities is unlimited. # It makes no difference if the nested entities are arrays or objects entities : # Name of nested entity - [ name : <string> ] # Collection's optinal alias (used inside regos) [ alias : <string> | optional ]","title":"datastore.yml"},{"location":"operations/Configuration/#connection-options","text":"Kelon supports different databases (PostgreSQL, MySQL and MongoDB) each of them having different connection options. To keep the configuration of connection options as simple as possible, Kelon just passes all key-value-pairs of each the datastore connection (despite the dedicated ones like i.e. username, host, port, etc.) directly to the used database adapter. Following table should help to lookup all available options for each supported database: Database Used driver Options PostgreSQL github.com/lib/pq Go Docs, Connection String Parameters MySQL github.com/go-sql-driver/mysql Go Docs, DSN Parameters MongoDB go.mongodb.org/mongo-driver/mongo Mongo-Docs, Connection options","title":"Connection options"},{"location":"operations/Configuration/#injecting-environment-variables","text":"Each value inside the datastore.yml file can be replaced with a string follwing the pattern ${<environment variable>} which is replaced with the value of the environment variable at startup.","title":"Injecting environment variables"},{"location":"operations/Configuration/#call-operandsdatastore-typeyml","text":"Open Policy Agent has builtin call operands which may not be the same as the ones of each datastore. Therefore each datastore-type has to have a mapping-file inside the folder 'call-operands'. The name of each file inside this directory has to match the type of the datastore. # Call operands map OPA's functions to datastore-native ones. # You find more advanced files in directory /call-operands call-operands : # Operand name inside OPA's context - [ op : <string> ] # Number of arguments the function call should take # Used for validation [ args : <int> ] # Mapping which mappes the OPA-native call to a Datastore-native call. # This is done by defining a pattern where all occurences of $<arg-pos> # are replaced with the original argument at position <arg-pos> (zero based). [ mapping : <string> ]","title":"call-operands/{datastore-type}.yml"},{"location":"operations/Configuration/#apiyml","text":"The datastore.yml contains all necessary configuration kelon needs to map incoming api-requests to OPA-Queries executed inside datastores. # Mappings for the APIs that your services expose apis : # API-Collection # Each collection can have a path prefix which is prepended to every API-Mapping # inside the collection. - [ path-prefix : <URL|string> ] # All rego-queries mapped by this API-collection will include # this datastore-alias as unknown. # This means that the regos this collection targets can contain # something like 'data.<datastore-alias>.<entity>.<attribute>' [ datastore : <datastore-alias|string> ] # Path-Mappings for incoming paths # (the most specific mapping is picked in case of multiple mappings) mappings : # Path-Mapping # Each mapping has to specify a path (regex) and a package which is used # by kelon to generate the target package of an mapped query. - [ path : <regex|string> ] # OPA's target package of this Path-Mapping [ package : <string> ] # HTTP-Methods this path should map (optional) # If no methods are specified, kellon will match [GET,PUT,POST,DELETE,PATCH] methods : - [ <string> ... ]","title":"api.yml"},{"location":"operations/Configuration/#opayml","text":"Internally used by Open Policy Agent. Klick here for more information. labels : app : Kelon region : europe-west3 environment : development decision_logs : console : true reporting : min_delay_seconds : 300 max_delay_seconds : 600 default_decision : /http/authz/allow","title":"opa.yml"},{"location":"operations/Deployment/","text":"Deployment","title":"Deployment"},{"location":"operations/Deployment/#deployment","text":"","title":"Deployment"},{"location":"operations/Monitoring/","text":"Monitoring","title":"Monitoring"},{"location":"operations/Monitoring/#monitoring","text":"","title":"Monitoring"},{"location":"operations/Security/","text":"Security","title":"Security"},{"location":"operations/Security/#security","text":"","title":"Security"}]}