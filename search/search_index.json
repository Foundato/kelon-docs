{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kelon About Kelon is a policy enforcement point, that is wrapping the Open Policy Agent (OPA) by adding more functionality in terms of microservices. Motivation Let's say you have some services you would like to have authorization implemented into. With this challenge in mind there are basically two options: 1. Use code to secure your endpoints In case of REST-Services nearly every framework provides something like Guards or so 2. Use Kelon to secure your endpoints Just add some small code snippets to your service (like Request-Interceptors) and let Kelon handle the decision for you Conclusion It's obvious that the second option not only increases the speed at which you'll implement your service ( focusing only on the functionality ), but also grants much more security because all your policies are stored and enforced in one place (they can also be separately tested). This is basically the problem that the Open Policy Agent solves. The only problem is that it is very hard to integrate the OPA into a project because it needs the data which is needed to enforce policies to be stored inside it. This leads to work flows where you copy an abstraction of your entire database into OPA which is not only redundant, but also leads to synchronization issues. Getting Started Getting started with Kelon is as easy as following one of the How-To guides. Local deployment Example Setup Appstore example (Spring-Boot & Vue.js)","title":"Introduction"},{"location":"#kelon","text":"","title":"Kelon"},{"location":"#about","text":"Kelon is a policy enforcement point, that is wrapping the Open Policy Agent (OPA) by adding more functionality in terms of microservices.","title":"About"},{"location":"#motivation","text":"Let's say you have some services you would like to have authorization implemented into. With this challenge in mind there are basically two options:","title":"Motivation"},{"location":"#1-use-code-to-secure-your-endpoints","text":"In case of REST-Services nearly every framework provides something like Guards or so","title":"1. Use code to secure your endpoints"},{"location":"#2-use-kelon-to-secure-your-endpoints","text":"Just add some small code snippets to your service (like Request-Interceptors) and let Kelon handle the decision for you","title":"2. Use Kelon to secure your endpoints"},{"location":"#conclusion","text":"It's obvious that the second option not only increases the speed at which you'll implement your service ( focusing only on the functionality ), but also grants much more security because all your policies are stored and enforced in one place (they can also be separately tested). This is basically the problem that the Open Policy Agent solves. The only problem is that it is very hard to integrate the OPA into a project because it needs the data which is needed to enforce policies to be stored inside it. This leads to work flows where you copy an abstraction of your entire database into OPA which is not only redundant, but also leads to synchronization issues.","title":"Conclusion"},{"location":"#getting-started","text":"Getting started with Kelon is as easy as following one of the How-To guides. Local deployment Example Setup Appstore example (Spring-Boot & Vue.js)","title":"Getting Started"},{"location":"how-to/Appstore-Example/","text":"Appstore example (Spring-Boot & Vue.js) To demonstrate how to use Kelon in a real world use case, we built a Kelon-enabled fork of Daniel-Seifert's spring-vue-appstore .","title":"Appstore example"},{"location":"how-to/Appstore-Example/#appstore-example-spring-boot-vuejs","text":"To demonstrate how to use Kelon in a real world use case, we built a Kelon-enabled fork of Daniel-Seifert's spring-vue-appstore .","title":"Appstore example (Spring-Boot &amp; Vue.js)"},{"location":"how-to/Local-Deployment/","text":"Local Deployment To run Kelon locally we recommend you to use Docker to build a container. # Clone the repository $ git clone git@github.com:Foundato/kelon.git # Build the container $ docker build . -t kelon:latest # Or install kelon on your local machine $ go mod download $ go build -o ./kelon ./cmd/kelon After kelon is installed, you have to create following configuration files that tell Kelon which data sources it should connect to and how it should map incoming requests to OPA-Packages. Configuration datastore.yml Defines all available datastores and their entities # Datastores to connect to datastores : mysql : # Datastore's alias (it will be used throughout all your policies) type : mysql # Datastore type connection : # Information about the datastore connection host : localhost port : 3306 database : appstore user : You password : SuperSecure # Entity-Schemas define the entities of one schema inside a datastore entity_schemas : mysql : # Datastore alias appstore : # Target schema entities : # List of all entities of the schema - name : users - name : app_rights - name : apps call-operands/mysql.yml Open Policy Agent has builtin call operands which may not be the same as the ones of each datasource. Therefore each datasource-type has to have a mappings-file inside the folder 'call-operands'. # Call operands map OPA's functions to datastore-native ones. # You find more advanced files in directory /call-operands call-operands : # Relational operands - op : eq args : 2 mapping : \"$0 = $1\" - op : equal args : 2 mapping : \"$0 = $1\" api.yml Map incoming api-requests to OPA-Queries executed on data sources. # Mappings for the APIs that your services expose apis : # Route all requests starting with /api to datastore with alias 'mysql' - path-prefix : /api datastore : mysql # Mappings for incoming paths (the most specific mapping is picked in case of multiple mappings) mappings : - path : /apps/.* # Matches [GET, POST] /api/apps/.* package : applications # Maps to OPA-Query 'data.applications.allow == true' # If no methods are supplied, all methods are matched methods : - GET - POST opa.yml Internally used by Open Policy Agent. labels : app : Kelon region : europe-west3 environment : development decision_logs : console : true reporting : min_delay_seconds : 300 max_delay_seconds : 600 default_decision : /http/authz/allow policies/applications.rego Contains OPA-Regos. Note the unknown 'mysql' here which is automatically used by Kelon to translate the request to path: '/api/apps/3' into the SQL-Statement: 'SELECT count(*) FROM appstore.apps WHERE apps.stars = 5 and apps.id = 3' package applications # Deny all by default allow = false # Path: GET /api/apps/<number> # All apps withe 5 stars can be viewed allow = true { input.method = \"GET\" input.path = [\"api\", \"apps\", appId] data.mysql.apps[app].stars == 5 app.id == appId } Run To run Kelon, there has to be a available MySQL database with the specified connection. Feel free to use the MySQL-Database from our example (which is already configured for above configs). $ docker-compose up -d mysql Now you should be able to run kelon: $ kelon start","title":"Local deployment"},{"location":"how-to/Local-Deployment/#local-deployment","text":"To run Kelon locally we recommend you to use Docker to build a container. # Clone the repository $ git clone git@github.com:Foundato/kelon.git # Build the container $ docker build . -t kelon:latest # Or install kelon on your local machine $ go mod download $ go build -o ./kelon ./cmd/kelon After kelon is installed, you have to create following configuration files that tell Kelon which data sources it should connect to and how it should map incoming requests to OPA-Packages.","title":"Local Deployment"},{"location":"how-to/Local-Deployment/#configuration","text":"","title":"Configuration"},{"location":"how-to/Local-Deployment/#datastoreyml","text":"Defines all available datastores and their entities # Datastores to connect to datastores : mysql : # Datastore's alias (it will be used throughout all your policies) type : mysql # Datastore type connection : # Information about the datastore connection host : localhost port : 3306 database : appstore user : You password : SuperSecure # Entity-Schemas define the entities of one schema inside a datastore entity_schemas : mysql : # Datastore alias appstore : # Target schema entities : # List of all entities of the schema - name : users - name : app_rights - name : apps","title":"datastore.yml"},{"location":"how-to/Local-Deployment/#call-operandsmysqlyml","text":"Open Policy Agent has builtin call operands which may not be the same as the ones of each datasource. Therefore each datasource-type has to have a mappings-file inside the folder 'call-operands'. # Call operands map OPA's functions to datastore-native ones. # You find more advanced files in directory /call-operands call-operands : # Relational operands - op : eq args : 2 mapping : \"$0 = $1\" - op : equal args : 2 mapping : \"$0 = $1\"","title":"call-operands/mysql.yml"},{"location":"how-to/Local-Deployment/#apiyml","text":"Map incoming api-requests to OPA-Queries executed on data sources. # Mappings for the APIs that your services expose apis : # Route all requests starting with /api to datastore with alias 'mysql' - path-prefix : /api datastore : mysql # Mappings for incoming paths (the most specific mapping is picked in case of multiple mappings) mappings : - path : /apps/.* # Matches [GET, POST] /api/apps/.* package : applications # Maps to OPA-Query 'data.applications.allow == true' # If no methods are supplied, all methods are matched methods : - GET - POST","title":"api.yml"},{"location":"how-to/Local-Deployment/#opayml","text":"Internally used by Open Policy Agent. labels : app : Kelon region : europe-west3 environment : development decision_logs : console : true reporting : min_delay_seconds : 300 max_delay_seconds : 600 default_decision : /http/authz/allow","title":"opa.yml"},{"location":"how-to/Local-Deployment/#policiesapplicationsrego","text":"Contains OPA-Regos. Note the unknown 'mysql' here which is automatically used by Kelon to translate the request to path: '/api/apps/3' into the SQL-Statement: 'SELECT count(*) FROM appstore.apps WHERE apps.stars = 5 and apps.id = 3' package applications # Deny all by default allow = false # Path: GET /api/apps/<number> # All apps withe 5 stars can be viewed allow = true { input.method = \"GET\" input.path = [\"api\", \"apps\", appId] data.mysql.apps[app].stars == 5 app.id == appId }","title":"policies/applications.rego"},{"location":"how-to/Local-Deployment/#run","text":"To run Kelon, there has to be a available MySQL database with the specified connection. Feel free to use the MySQL-Database from our example (which is already configured for above configs). $ docker-compose up -d mysql Now you should be able to run kelon: $ kelon start","title":"Run"},{"location":"how-to/Run-The-Example/","text":"Run the example In order to demonstrate the usage of Kelon, we provide an example setup which shows a configuration of kelon with two separate datastores (PostgreSQL & MySQL). To demonstrate the ease of switching between datastores with kelon, both datastores have the same data set. Datamodel The datamodel is fairly simple but contains everything you will need in a more advanced setup (i.e. JOINS). Example Dataset appstore.users id name age friend 1 Arnold 73 John Connor 2 Kevin 21 Kevin 3 Anyone null Anyone appstore.apps id name stars 2 First App for everyone 1 2 Arnold's App 2 3 Famous App 5 appstore.app_rights app_id user_id right 2 1 OWNER Policies This example project contains four basic policies with should give you a better understanding of how to write policies using Kelon. If you have a closer look at datastore.yml & api.yml you will notice, that the table's data inside your datastores can be 'magically' accessed inside the OPA-Regos with the following Syntax: data.{datastore-alias}.{entity}.{column} With this handy feature, we can write following policies: Users with right 'OWNER' on app can access it always Path: GET /api/{datastore-alias}/apps/:app_id All apps with 5 stars are public Path: GET /api/{datastore-alias}/apps/:app_id The first app is public Path: GET /api/{datastore-alias}/apps/:app_id All users that are a friends of Kevin are allowed see everything Path: GET /api/{datastore-alias}/* Start the environment The entire example environment can be started with the provided docker-compose in the project's root directory with following command $ docker-compose up -d This will start following components: Kelon Port: 8181 MySQL Port: 3306 PostgreSQL Port: 5432 Adminer Port: 8080 After all containers are built and up, you can verify that everything is up by performing a valid request: to PostgreSQL $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } to MySQL $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/mysql/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } Play around You now have a complete setup of Kelon which you can use to play around with a little. You can i.e. try to access an app you shouldn't be allowed to: $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/2\", \"user\": \"Anyone\"}}' > { \"result\" :false } Or access an app with 5 stars (which the user 'Anyone' is allowed to): $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/3\", \"user\": \"Anyone\"}}' > { \"result\" :true } There is also a POSTMAN-COLLECTION in the example directory which contains a bunch of queries agains all three datasources (PostgreSQL, MySQL, MongoDB). Feel free to play around with the existing regos and databases to get a feeling of how to write policies and configure Kelon. Clean up After you are done, just stop the entire setup by running: $ docker-compose down","title":"Run the example"},{"location":"how-to/Run-The-Example/#run-the-example","text":"In order to demonstrate the usage of Kelon, we provide an example setup which shows a configuration of kelon with two separate datastores (PostgreSQL & MySQL). To demonstrate the ease of switching between datastores with kelon, both datastores have the same data set.","title":"Run the example"},{"location":"how-to/Run-The-Example/#datamodel","text":"The datamodel is fairly simple but contains everything you will need in a more advanced setup (i.e. JOINS).","title":"Datamodel"},{"location":"how-to/Run-The-Example/#example-dataset","text":"","title":"Example Dataset"},{"location":"how-to/Run-The-Example/#appstoreusers","text":"id name age friend 1 Arnold 73 John Connor 2 Kevin 21 Kevin 3 Anyone null Anyone","title":"appstore.users"},{"location":"how-to/Run-The-Example/#appstoreapps","text":"id name stars 2 First App for everyone 1 2 Arnold's App 2 3 Famous App 5","title":"appstore.apps"},{"location":"how-to/Run-The-Example/#appstoreapp_rights","text":"app_id user_id right 2 1 OWNER","title":"appstore.app_rights"},{"location":"how-to/Run-The-Example/#policies","text":"This example project contains four basic policies with should give you a better understanding of how to write policies using Kelon. If you have a closer look at datastore.yml & api.yml you will notice, that the table's data inside your datastores can be 'magically' accessed inside the OPA-Regos with the following Syntax: data.{datastore-alias}.{entity}.{column} With this handy feature, we can write following policies: Users with right 'OWNER' on app can access it always Path: GET /api/{datastore-alias}/apps/:app_id All apps with 5 stars are public Path: GET /api/{datastore-alias}/apps/:app_id The first app is public Path: GET /api/{datastore-alias}/apps/:app_id All users that are a friends of Kevin are allowed see everything Path: GET /api/{datastore-alias}/*","title":"Policies"},{"location":"how-to/Run-The-Example/#start-the-environment","text":"The entire example environment can be started with the provided docker-compose in the project's root directory with following command $ docker-compose up -d This will start following components: Kelon Port: 8181 MySQL Port: 3306 PostgreSQL Port: 5432 Adminer Port: 8080 After all containers are built and up, you can verify that everything is up by performing a valid request: to PostgreSQL $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } to MySQL $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/mysql/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true }","title":"Start the environment"},{"location":"how-to/Run-The-Example/#play-around","text":"You now have a complete setup of Kelon which you can use to play around with a little. You can i.e. try to access an app you shouldn't be allowed to: $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/2\", \"user\": \"Anyone\"}}' > { \"result\" :false } Or access an app with 5 stars (which the user 'Anyone' is allowed to): $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/3\", \"user\": \"Anyone\"}}' > { \"result\" :true } There is also a POSTMAN-COLLECTION in the example directory which contains a bunch of queries agains all three datasources (PostgreSQL, MySQL, MongoDB). Feel free to play around with the existing regos and databases to get a feeling of how to write policies and configure Kelon.","title":"Play around"},{"location":"how-to/Run-The-Example/#clean-up","text":"After you are done, just stop the entire setup by running: $ docker-compose down","title":"Clean up"},{"location":"kelon/Configuration/","text":"Configuration datastore.yml The datastore.yml defines all available datastores and their entities. # List of all datastores which kelon should be able to connect to # Each datastore has to have an entity schema configured! datastores : # Datastore's alias (it will be used throughout all your policies). mysql : # Datastore type # Kelon supports [mysql, postgres, mongo] [ type : <string> ] # Properties that are needed to connect to the datastore connection : # Hostname or IP of the database [ host : <string> ] # Port under which the database is available [ port : <int> ] # Name of the database to connect to # Many database servers run multiple databases. # In this case create one datastore for each database [ database : <string> ] # The user which is used for the database connection [ user : <string> ] # The password of the user [ password : <string> ] # Entity-Schemas define the entities of one schema inside a datastore. # An entity_schema has several purposes: # => Help kelon to detect misspellings in regos # => Create entity-aliases for complex table-names # => Define the structure of nested entities (Just for No-SQL DBs) entity_schemas : # Datastore's alias # This example shows how each SQL-Datastore should be configured. mysql : # Schema name # Kelon automatically adds the schema name to entities # This means that 'data.mysql.users' inside a rego will be translated # to 'appstore.users' in the resulting SQL-Statement. # # !!! The entities inside all schemas of one Datastore have to be disjunct !!! # Otherwise kelon will fail on startup appstore : # List of all entities of schema 'appstore' entities : # Entity with the name inside the datastore - [ name : <string> ] # And an optional alias (used inside regos) [ alias : <string> | optional ] # This example shows how each No-SQL-Datastore should be configured. mongo : # Schema name # Because No-SQL-Datastores don't have concept for schemas, # Kelon ignores the schema name for i.e. a MongoDB. # # !!! The entities inside all schemas of one Datastore have to be disjunct !!! # Otherwise kelon will fail on startup appstore : # List of all entities (in case of MongoDB each entity is a collection) entities : # Collection with it's name inside the datastore - [ name : <string> ] # Collection's optinal alias (used inside regos) [ alias : <string> | optional ] # Nested entities (Only supported for No-SQL-Datastores) # The depth of nesting entities is unlimited. # It makes no difference if the nested entities are arrays or objects entities : # Name of nested entity - [ name : <string> ] # Collection's optinal alias (used inside regos) [ alias : <string> | optional ] call-operands/{datastore-type}.yml Open Policy Agent has builtin call operands which may not be the same as the ones of each datastore. Therefore each datastore-type has to have a mapping-file inside the folder 'call-operands'. The name of each file inside this directory has to match the type of the datastore. # Call operands map OPA's functions to datastore-native ones. # You find more advanced files in directory /call-operands call-operands : # Operand name inside OPA's context - [ op : <string> ] # Number of arguments the function call should take # Used for validation [ args : <int> ] # Mapping which mappes the OPA-native call to a Datastore-native call. # This is done by defining a pattern where all occurences of $<arg-pos> # are replaced with the original argument at position <arg-pos> (zero based). [ mapping : <string> ] api.yml The datastore.yml contains all necessary configuration kelon needs to map incoming api-requests to OPA-Queries executed inside datastores. # Mappings for the APIs that your services expose apis : # API-Collection # Each collection can have a path prefix which is prepended to every API-Mapping # inside the collection. - [ path-prefix : <URL|string> ] # All rego-queries mapped by this API-collection will include # this datastore-alias as unknown. # This means that the regos this collection targets can contain # something like 'data.<datastore-alias>.<entity>.<attribute>' [ datastore : <datastore-alias|string> ] # Path-Mappings for incoming paths # (the most specific mapping is picked in case of multiple mappings) mappings : # Path-Mapping # Each mapping has to specify a path (regex) and a package which is used # by kelon to generate the target package of an mapped query. - [ path : <regex|string> ] # OPA's target package of this Path-Mapping [ package : <string> ] # HTTP-Methods this path should map (optional) # If no methods are specified, kellon will match [GET,PUT,POST,DELETE,PATCH] methods : - [ <string> ... ] opa.yml Internally used by Open Policy Agent. Klick here for more information. labels : app : Kelon region : europe-west3 environment : development decision_logs : console : true reporting : min_delay_seconds : 300 max_delay_seconds : 600 default_decision : /http/authz/allow","title":"Configuration"},{"location":"kelon/Configuration/#configuration","text":"","title":"Configuration"},{"location":"kelon/Configuration/#datastoreyml","text":"The datastore.yml defines all available datastores and their entities. # List of all datastores which kelon should be able to connect to # Each datastore has to have an entity schema configured! datastores : # Datastore's alias (it will be used throughout all your policies). mysql : # Datastore type # Kelon supports [mysql, postgres, mongo] [ type : <string> ] # Properties that are needed to connect to the datastore connection : # Hostname or IP of the database [ host : <string> ] # Port under which the database is available [ port : <int> ] # Name of the database to connect to # Many database servers run multiple databases. # In this case create one datastore for each database [ database : <string> ] # The user which is used for the database connection [ user : <string> ] # The password of the user [ password : <string> ] # Entity-Schemas define the entities of one schema inside a datastore. # An entity_schema has several purposes: # => Help kelon to detect misspellings in regos # => Create entity-aliases for complex table-names # => Define the structure of nested entities (Just for No-SQL DBs) entity_schemas : # Datastore's alias # This example shows how each SQL-Datastore should be configured. mysql : # Schema name # Kelon automatically adds the schema name to entities # This means that 'data.mysql.users' inside a rego will be translated # to 'appstore.users' in the resulting SQL-Statement. # # !!! The entities inside all schemas of one Datastore have to be disjunct !!! # Otherwise kelon will fail on startup appstore : # List of all entities of schema 'appstore' entities : # Entity with the name inside the datastore - [ name : <string> ] # And an optional alias (used inside regos) [ alias : <string> | optional ] # This example shows how each No-SQL-Datastore should be configured. mongo : # Schema name # Because No-SQL-Datastores don't have concept for schemas, # Kelon ignores the schema name for i.e. a MongoDB. # # !!! The entities inside all schemas of one Datastore have to be disjunct !!! # Otherwise kelon will fail on startup appstore : # List of all entities (in case of MongoDB each entity is a collection) entities : # Collection with it's name inside the datastore - [ name : <string> ] # Collection's optinal alias (used inside regos) [ alias : <string> | optional ] # Nested entities (Only supported for No-SQL-Datastores) # The depth of nesting entities is unlimited. # It makes no difference if the nested entities are arrays or objects entities : # Name of nested entity - [ name : <string> ] # Collection's optinal alias (used inside regos) [ alias : <string> | optional ]","title":"datastore.yml"},{"location":"kelon/Configuration/#call-operandsdatastore-typeyml","text":"Open Policy Agent has builtin call operands which may not be the same as the ones of each datastore. Therefore each datastore-type has to have a mapping-file inside the folder 'call-operands'. The name of each file inside this directory has to match the type of the datastore. # Call operands map OPA's functions to datastore-native ones. # You find more advanced files in directory /call-operands call-operands : # Operand name inside OPA's context - [ op : <string> ] # Number of arguments the function call should take # Used for validation [ args : <int> ] # Mapping which mappes the OPA-native call to a Datastore-native call. # This is done by defining a pattern where all occurences of $<arg-pos> # are replaced with the original argument at position <arg-pos> (zero based). [ mapping : <string> ]","title":"call-operands/{datastore-type}.yml"},{"location":"kelon/Configuration/#apiyml","text":"The datastore.yml contains all necessary configuration kelon needs to map incoming api-requests to OPA-Queries executed inside datastores. # Mappings for the APIs that your services expose apis : # API-Collection # Each collection can have a path prefix which is prepended to every API-Mapping # inside the collection. - [ path-prefix : <URL|string> ] # All rego-queries mapped by this API-collection will include # this datastore-alias as unknown. # This means that the regos this collection targets can contain # something like 'data.<datastore-alias>.<entity>.<attribute>' [ datastore : <datastore-alias|string> ] # Path-Mappings for incoming paths # (the most specific mapping is picked in case of multiple mappings) mappings : # Path-Mapping # Each mapping has to specify a path (regex) and a package which is used # by kelon to generate the target package of an mapped query. - [ path : <regex|string> ] # OPA's target package of this Path-Mapping [ package : <string> ] # HTTP-Methods this path should map (optional) # If no methods are specified, kellon will match [GET,PUT,POST,DELETE,PATCH] methods : - [ <string> ... ]","title":"api.yml"},{"location":"kelon/Configuration/#opayml","text":"Internally used by Open Policy Agent. Klick here for more information. labels : app : Kelon region : europe-west3 environment : development decision_logs : console : true reporting : min_delay_seconds : 300 max_delay_seconds : 600 default_decision : /http/authz/allow","title":"opa.yml"},{"location":"kelon/Example-Deconstruction/","text":"Deconstructing the example To become a deep understanding of how Kelon works in action, we now deconstruct the entire internal process of kelon while executing the example setup provided inside the repository. Therefore the following three infographics show three example queries made to Kelon. (My)SQL The example for PostgreSQL is nearly the same (just swap 'mysql' with 'pg'). And now No-SQL When we run the example above against the MongoDB, there is also not much difference in each processing step. Only the generated output are now following native MongoDB-Query: users . find ({ \"$or\" : [ { \"name\" : \"Arnold\" , \"friend\" : \"Kevin\" } ] }) apps . find ({ \"$or\" : [ { \"id\" : 2 , \"stars\" : { \"$gt\" : 2 }, \"rights.right\" : \"OWNER\" , \"rights.user.name\" : \"Arnold\" }, { \"stars\" : 5 , \"id\" : 2 } ] })","title":"Deconstructing the example"},{"location":"kelon/Example-Deconstruction/#deconstructing-the-example","text":"To become a deep understanding of how Kelon works in action, we now deconstruct the entire internal process of kelon while executing the example setup provided inside the repository. Therefore the following three infographics show three example queries made to Kelon.","title":"Deconstructing the example"},{"location":"kelon/Example-Deconstruction/#mysql","text":"The example for PostgreSQL is nearly the same (just swap 'mysql' with 'pg').","title":"(My)SQL"},{"location":"kelon/Example-Deconstruction/#and-now-no-sql","text":"When we run the example above against the MongoDB, there is also not much difference in each processing step. Only the generated output are now following native MongoDB-Query: users . find ({ \"$or\" : [ { \"name\" : \"Arnold\" , \"friend\" : \"Kevin\" } ] }) apps . find ({ \"$or\" : [ { \"id\" : 2 , \"stars\" : { \"$gt\" : 2 }, \"rights.right\" : \"OWNER\" , \"rights.user.name\" : \"Arnold\" }, { \"stars\" : 5 , \"id\" : 2 } ] })","title":"And now No-SQL"},{"location":"kelon/In-A-Nutshell/","text":"Kelon in a nutshell The following infographic shows the entire internal execution chain of Kelon in conjunction with the configuration files affecting each step.","title":"In a nutshell"},{"location":"kelon/In-A-Nutshell/#kelon-in-a-nutshell","text":"The following infographic shows the entire internal execution chain of Kelon in conjunction with the configuration files affecting each step.","title":"Kelon in a nutshell"},{"location":"kelon/Initial-Exploration/","text":"Introduction To get a better understanding of how kelon is built, have a look at following infographics to get a better understanding of the surrounding environment of Kelon. External interfaces Request flow Interface usage exploration In order to intercept each request in your backend and send it to Kelon, you have to implement some kind of middleware in your backend. All big backend-frameworks contain middleware-APIs which help you to write this interception with only a view lines of code. Following interface usage exploration lists a view common frameworks and their authorization-middleware components. Note the two different approaches of implementing the authorization-middleware (either by having one interceptor which sends all incoming requests to kelon or multiple interceptors). We strongly recommend you to only use one interceptor!","title":"Initial exploration"},{"location":"kelon/Initial-Exploration/#introduction","text":"To get a better understanding of how kelon is built, have a look at following infographics to get a better understanding of the surrounding environment of Kelon.","title":"Introduction"},{"location":"kelon/Initial-Exploration/#external-interfaces","text":"","title":"External interfaces"},{"location":"kelon/Initial-Exploration/#request-flow","text":"","title":"Request flow"},{"location":"kelon/Initial-Exploration/#interface-usage-exploration","text":"In order to intercept each request in your backend and send it to Kelon, you have to implement some kind of middleware in your backend. All big backend-frameworks contain middleware-APIs which help you to write this interception with only a view lines of code. Following interface usage exploration lists a view common frameworks and their authorization-middleware components. Note the two different approaches of implementing the authorization-middleware (either by having one interceptor which sends all incoming requests to kelon or multiple interceptors). We strongly recommend you to only use one interceptor!","title":"Interface usage exploration"},{"location":"kelon/architecture/Components/","text":"Components The core architecture of kelon was designed to be extremely modular and support the writing and loading of own implementations of components (so called plugins). Right now there is no mechanism for plugin loading, but as long as you implement Kelon's interfaces, you will be good to go when plugin-loading is available!","title":"Components"},{"location":"kelon/architecture/Components/#components","text":"The core architecture of kelon was designed to be extremely modular and support the writing and loading of own implementations of components (so called plugins). Right now there is no mechanism for plugin loading, but as long as you implement Kelon's interfaces, you will be good to go when plugin-loading is available!","title":"Components"},{"location":"kelon/architecture/Query-AST/","text":"Query AST Each Datastore has the task to translate a so called Query-AST into its native query language. This means, that you have to Walk the entire Query-AST and translate it if you want to write your own Datastore-Plugin! It is worth mentioning that the method 'Walk' of every Node of the Query-AST walks the entire node's subtree (Visitor Pattern) buttom-up & left-right including the calling node as last visit.","title":"Query AST"},{"location":"kelon/architecture/Query-AST/#query-ast","text":"Each Datastore has the task to translate a so called Query-AST into its native query language. This means, that you have to Walk the entire Query-AST and translate it if you want to write your own Datastore-Plugin! It is worth mentioning that the method 'Walk' of every Node of the Query-AST walks the entire node's subtree (Visitor Pattern) buttom-up & left-right including the calling node as last visit.","title":"Query AST"},{"location":"kelon/architecture/Request-Mapping/","text":"Request mapping Each incoming request to the backend has to be intercepted and wrapped in a JSON-object called \"input\". This object has to contain all important information about the incoming request like 'method', 'path' and i.e. 'authorization'. Kelon takes the input-object, adds more information to it and compiles it with the Open Policy Agent. This means you also have access to i.e. Query-Parameters a client sent to your backend inside your Regos!","title":"Request mapping"},{"location":"kelon/architecture/Request-Mapping/#request-mapping","text":"Each incoming request to the backend has to be intercepted and wrapped in a JSON-object called \"input\". This object has to contain all important information about the incoming request like 'method', 'path' and i.e. 'authorization'. Kelon takes the input-object, adds more information to it and compiles it with the Open Policy Agent. This means you also have access to i.e. Query-Parameters a client sent to your backend inside your Regos!","title":"Request mapping"}]}