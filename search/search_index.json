{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kelon About Kelon is a policy enforcement point, that is wrapping the Open Policy Agent (OPA) by adding more functionality in terms of microservices. Motivation Let's say you have some services you would like to have authorization implemented into. With this challenge in mind there are basically two options: 1. Use code to secure your endpoints In case of REST-Services nearly every framework provides something like Guards or so 2. Use Kelon to secure your endpoints Just add some small code snippets to your service (like Request-Interceptors) and let Kelon handle the decision for you Conclusion It's obvious that the second option not only increases the speed at which you'll implement your service ( focusing only on the functionality ), but also grants much more security because all your policies are stored and enforced in one place (they can also be separately tested). This is basically the problem that the Open Policy Agent solves. The only problem is that it is very hard to integrate the OPA into a project because it needs the data which is needed to enforce policies to be stored inside it. This leads to work flows where you copy an abstraction of your entire database into OPA which is not only redundant, but also leads to synchronization issues. Getting Started Getting started with Kelon is as easy as following one of the How-To guides. Example Setup Appstore example (Spring-Boot & Vue.js)","title":"Introduction"},{"location":"#kelon","text":"","title":"Kelon"},{"location":"#about","text":"Kelon is a policy enforcement point, that is wrapping the Open Policy Agent (OPA) by adding more functionality in terms of microservices.","title":"About"},{"location":"#motivation","text":"Let's say you have some services you would like to have authorization implemented into. With this challenge in mind there are basically two options:","title":"Motivation"},{"location":"#1-use-code-to-secure-your-endpoints","text":"In case of REST-Services nearly every framework provides something like Guards or so","title":"1. Use code to secure your endpoints"},{"location":"#2-use-kelon-to-secure-your-endpoints","text":"Just add some small code snippets to your service (like Request-Interceptors) and let Kelon handle the decision for you","title":"2. Use Kelon to secure your endpoints"},{"location":"#conclusion","text":"It's obvious that the second option not only increases the speed at which you'll implement your service ( focusing only on the functionality ), but also grants much more security because all your policies are stored and enforced in one place (they can also be separately tested). This is basically the problem that the Open Policy Agent solves. The only problem is that it is very hard to integrate the OPA into a project because it needs the data which is needed to enforce policies to be stored inside it. This leads to work flows where you copy an abstraction of your entire database into OPA which is not only redundant, but also leads to synchronization issues.","title":"Conclusion"},{"location":"#getting-started","text":"Getting started with Kelon is as easy as following one of the How-To guides. Example Setup Appstore example (Spring-Boot & Vue.js)","title":"Getting Started"},{"location":"core/architecture/Components/","text":"Components The main goal of Kelons core design was to make extensible with ease while keeping it functional and efficient. Therefore the entire applicaiton logic was divided into small closely coupled components which can be easily replaced by self implemented plugins. Right now there is no mechanism for plugin loading, but as long as you implement Kelon's interfaces, you will be good to go when plugin-loading is available!","title":"Components"},{"location":"core/architecture/Components/#components","text":"The main goal of Kelons core design was to make extensible with ease while keeping it functional and efficient. Therefore the entire applicaiton logic was divided into small closely coupled components which can be easily replaced by self implemented plugins. Right now there is no mechanism for plugin loading, but as long as you implement Kelon's interfaces, you will be good to go when plugin-loading is available!","title":"Components"},{"location":"core/architecture/Policy-Translation/","text":"Policy Translation Kelon in a Nutshell Internally each request sent to Kelon goes through the same processing chain to finally become a translated native datastore-query. Following info graphic shows all configuration files and their interaction throughout this chain. Deconstructing the example To become a deep understanding of how Kelon works in action, we now deconstruct the entire internal process of Kelon while executing the example setup provided inside the repository. Therefore the following infographic shows an example query and its entire way through Kelon. (My)SQL The example for PostgreSQL is nearly the same (just swap 'mysql' with 'pg'). And now No-SQL When we run the example above against the MongoDB, there is also not much difference in each processing step. Only the generated output are now following native MongoDB-Query: users . find ({ \"$or\" : [ { \"name\" : \"Arnold\" , \"friend\" : \"Kevin\" } ] }) apps . find ({ \"$or\" : [ { \"id\" : 2 , \"stars\" : { \"$gt\" : 2 }, \"rights.right\" : \"OWNER\" , \"rights.user.name\" : \"Arnold\" }, { \"stars\" : 5 , \"id\" : 2 } ] })","title":"Policy Translation"},{"location":"core/architecture/Policy-Translation/#policy-translation","text":"","title":"Policy Translation"},{"location":"core/architecture/Policy-Translation/#kelon-in-a-nutshell","text":"Internally each request sent to Kelon goes through the same processing chain to finally become a translated native datastore-query. Following info graphic shows all configuration files and their interaction throughout this chain.","title":"Kelon in a Nutshell"},{"location":"core/architecture/Policy-Translation/#deconstructing-the-example","text":"To become a deep understanding of how Kelon works in action, we now deconstruct the entire internal process of Kelon while executing the example setup provided inside the repository. Therefore the following infographic shows an example query and its entire way through Kelon.","title":"Deconstructing the example"},{"location":"core/architecture/Policy-Translation/#mysql","text":"The example for PostgreSQL is nearly the same (just swap 'mysql' with 'pg').","title":"(My)SQL"},{"location":"core/architecture/Policy-Translation/#and-now-no-sql","text":"When we run the example above against the MongoDB, there is also not much difference in each processing step. Only the generated output are now following native MongoDB-Query: users . find ({ \"$or\" : [ { \"name\" : \"Arnold\" , \"friend\" : \"Kevin\" } ] }) apps . find ({ \"$or\" : [ { \"id\" : 2 , \"stars\" : { \"$gt\" : 2 }, \"rights.right\" : \"OWNER\" , \"rights.user.name\" : \"Arnold\" }, { \"stars\" : 5 , \"id\" : 2 } ] })","title":"And now No-SQL"},{"location":"core/architecture/Query-AST/","text":"Query AST Each Datastore has the task to translate a so called Query-AST into its native query language (which might become important to you as your datastore isn't supported by kelon yet). This means, that you have to Walk the entire Query-AST and translate it if you want to write your own Datastore-Plugin! It is worth mentioning that the method 'Walk' of every Node of the Query-AST walks the entire node's subtree (Visitor Pattern) buttom-up & left-right including the calling node as last visit.","title":"Query-AST"},{"location":"core/architecture/Query-AST/#query-ast","text":"Each Datastore has the task to translate a so called Query-AST into its native query language (which might become important to you as your datastore isn't supported by kelon yet). This means, that you have to Walk the entire Query-AST and translate it if you want to write your own Datastore-Plugin! It is worth mentioning that the method 'Walk' of every Node of the Query-AST walks the entire node's subtree (Visitor Pattern) buttom-up & left-right including the calling node as last visit.","title":"Query AST"},{"location":"core/extend/Write-Call-Operand_Mappings/","text":"","title":"Write Call Operand Mappings"},{"location":"core/extend/Write-Datastore-Plugin/","text":"","title":"Write a datasource plugin"},{"location":"core/extend/Write-Plugins/","text":"Write plugins","title":"Writing plugins"},{"location":"core/extend/Write-Plugins/#write-plugins","text":"","title":"Write plugins"},{"location":"core/integration/Kelon-Envoy/","text":"Kelon implements Envoy's External Authorization API which makes it quite easy to integrate it with Envoy. This setup becomes quite handy if you want to keep all your currently deployed services untouched and deploy Kelon together with Envoy as central gateway which authorizes the entire traffic coming in your cluster. The complete deployment of Kelon and Envoy as Gateway for our Appstore-Example inside Kubernetes is also available here Minimal setup To enable the Kelon's GRPC-Encpoint which is used by Envoy to authorize all request you just have to set the flag --envoy-port to a valid port and that's it. The minimal config to setup Envoy with is following: admin : access_log_path : \"/dev/null\" address : # Address and Port for envoy's admin interface socket_address : address : 0.0.0.0 port_value : 8001 static_resources : listeners : - address : # Address and Port Envoy is listening on socket_address : address : 0.0.0.0 port_value : 8000 filter_chains : - filters : - name : envoy.http_connection_manager typed_config : \"@type\" : type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager codec_type : auto stat_prefix : ingress_http route_config : name : local_route # Forward all incoming traffic to your service after all filters have passed virtual_hosts : - name : backend domains : - \"*\" routes : - match : prefix : \"/\" route : cluster : service # Entire filter chain which has to pass before # Envoy sends requests to your service http_filters : - name : envoy.ext_authz config : with_request_body : max_request_bytes : 8192 allow_partial_message : true failure_mode_allow : false grpc_service : google_grpc : target_uri : \"<uri to kelon>:<port under which kelon waits for envoy requests>\" stat_prefix : ext_authz timeout : 0.5s - name : envoy.router typed_config : {} clusters : - name : service connect_timeout : 0.25s type : strict_dns lb_policy : round_robin load_assignment : cluster_name : service endpoints : - lb_endpoints : - endpoint : address : # Your deployed service which you want to protect socket_address : address : <uri to your deployed service> port_value : <port of your service> CORS While this is a working setup of Envoy and Kelon, we also recommend to add at least Envoy's CORS-Filter in front of ext_auth to correctly terminate all CORS-Headers of inconming traffic. Following Config of envoy shows how to include Envoy's CORS-Filter: admin : access_log_path : \"/dev/null\" address : socket_address : address : 0.0.0.0 port_value : 8001 static_resources : listeners : - address : socket_address : address : 0.0.0.0 port_value : 8000 filter_chains : - filters : - name : envoy.http_connection_manager typed_config : \"@type\" : type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager codec_type : auto stat_prefix : ingress_http route_config : name : local_route virtual_hosts : - name : backend domains : - \"*\" # ======================================= # Configure CORS-Filter for each service cors : allow_origin_string_match : - safe_regex : google_re2 : {} regex : \\* allow_methods : \"*\" allow_headers : \"*\" filter_enabled : default_value : numerator : 100 denominator : HUNDRED runtime_key : cors.www.enabled shadow_enabled : default_value : numerator : 0 denominator : HUNDRED runtime_key : cors.www.shadow_enabled routes : - match : prefix : \"/\" route : cluster : service # ======================================= http_filters : # ======================================= # Add CORS filter before Kelon inside the filter chain - name : envoy.cors typed_config : {} # ======================================= - name : envoy.ext_authz config : with_request_body : max_request_bytes : 8192 allow_partial_message : true failure_mode_allow : false grpc_service : google_grpc : target_uri : \"<uri to kelon>:<port under which kelon waits for envoy requests>\" stat_prefix : ext_authz timeout : 0.5s - name : envoy.router typed_config : {} clusters : - name : service connect_timeout : 0.25s type : strict_dns lb_policy : round_robin load_assignment : cluster_name : service endpoints : - lb_endpoints : - endpoint : address : socket_address : address : <uri to your deployed service> port_value : <port of your service> Authentication (Auth0 & JWKS) If you want to keep Authorization as well as Authentication completely away from your services, you can also add Envoy's JWT-Auth-Filter to your filter chain. With this setup all of your services can completely focus on their main task... and this is business-logic and not authenticating or authorizing it! Following Config of envoy shows how to include Envoy's JWT-Auth-Filter: admin : access_log_path : \"/dev/null\" address : socket_address : address : 0.0.0.0 port_value : 8001 static_resources : listeners : - address : socket_address : address : 0.0.0.0 port_value : 8000 filter_chains : - filters : - name : envoy.http_connection_manager typed_config : \"@type\" : type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager codec_type : auto stat_prefix : ingress_http route_config : name : local_route virtual_hosts : - name : backend domains : - \"*\" cors : allow_origin_string_match : - safe_regex : google_re2 : {} regex : \\* allow_methods : \"*\" allow_headers : \"*\" filter_enabled : default_value : numerator : 100 denominator : HUNDRED runtime_key : cors.www.enabled shadow_enabled : default_value : numerator : 0 denominator : HUNDRED runtime_key : cors.www.shadow_enabled routes : - match : prefix : \"/\" route : cluster : service http_filters : - name : envoy.cors typed_config : {} # ======================================= # Add and configure JWT-Auth-Filter - name : envoy.filters.http.jwt_authn config : providers : provider1 : issuer : <issuer of your tokens. i.e. https://dev-kelon.eu.auth0.com/> remote_jwks : http_uri : uri : <uri where to fetch public keys from. i.e. https://dev-kelon.eu.auth0.com/.well-known/jwks.json> cluster : auth0 timeout : seconds : 5 rules : # Completely ignore health checks for authentication - match : prefix : /health - match : # Completely ignore login for authentication prefix : /api/login # Authenticate all requests against /api/apps - match : prefix : /api/apps requires : provider_name : provider1 # ======================================= - name : envoy.ext_authz config : with_request_body : max_request_bytes : 8192 allow_partial_message : true failure_mode_allow : false grpc_service : google_grpc : target_uri : \"<uri to kelon>:<port under which kelon waits for envoy requests>\" stat_prefix : ext_authz timeout : 0.5s - name : envoy.router typed_config : {} clusters : - name : service connect_timeout : 0.25s type : strict_dns lb_policy : round_robin load_assignment : cluster_name : service endpoints : - lb_endpoints : - endpoint : address : socket_address : address : <uri to your deployed service> port_value : <port of your service> # ======================================= # You also have to specify a cluster which describes the authentication endpoint - name : auth0 connect_timeout : 0.25s type : strict_dns lb_policy : round_robin load_assignment : cluster_name : auth0 endpoints : - lb_endpoints : - endpoint : address : socket_address : address : <uri to your auth provider. i.e. dev-kelon.eu.auth0.com> port_value : 443 transport_socket : name : envoy.transport_sockets.tls typed_config : \"@type\" : type.googleapis.com/envoy.api.v2.auth.UpstreamTlsContext common_tls_context : validation_context : trusted_ca : filename : \"/etc/ssl/certs/ca-certificates.crt\" sni : <server name indication of your auth provider. i.e. dev-kelon.eu.auth0.com>","title":"Kelon and Envoy"},{"location":"core/integration/Kelon-Envoy/#minimal-setup","text":"To enable the Kelon's GRPC-Encpoint which is used by Envoy to authorize all request you just have to set the flag --envoy-port to a valid port and that's it. The minimal config to setup Envoy with is following: admin : access_log_path : \"/dev/null\" address : # Address and Port for envoy's admin interface socket_address : address : 0.0.0.0 port_value : 8001 static_resources : listeners : - address : # Address and Port Envoy is listening on socket_address : address : 0.0.0.0 port_value : 8000 filter_chains : - filters : - name : envoy.http_connection_manager typed_config : \"@type\" : type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager codec_type : auto stat_prefix : ingress_http route_config : name : local_route # Forward all incoming traffic to your service after all filters have passed virtual_hosts : - name : backend domains : - \"*\" routes : - match : prefix : \"/\" route : cluster : service # Entire filter chain which has to pass before # Envoy sends requests to your service http_filters : - name : envoy.ext_authz config : with_request_body : max_request_bytes : 8192 allow_partial_message : true failure_mode_allow : false grpc_service : google_grpc : target_uri : \"<uri to kelon>:<port under which kelon waits for envoy requests>\" stat_prefix : ext_authz timeout : 0.5s - name : envoy.router typed_config : {} clusters : - name : service connect_timeout : 0.25s type : strict_dns lb_policy : round_robin load_assignment : cluster_name : service endpoints : - lb_endpoints : - endpoint : address : # Your deployed service which you want to protect socket_address : address : <uri to your deployed service> port_value : <port of your service>","title":"Minimal setup"},{"location":"core/integration/Kelon-Envoy/#cors","text":"While this is a working setup of Envoy and Kelon, we also recommend to add at least Envoy's CORS-Filter in front of ext_auth to correctly terminate all CORS-Headers of inconming traffic. Following Config of envoy shows how to include Envoy's CORS-Filter: admin : access_log_path : \"/dev/null\" address : socket_address : address : 0.0.0.0 port_value : 8001 static_resources : listeners : - address : socket_address : address : 0.0.0.0 port_value : 8000 filter_chains : - filters : - name : envoy.http_connection_manager typed_config : \"@type\" : type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager codec_type : auto stat_prefix : ingress_http route_config : name : local_route virtual_hosts : - name : backend domains : - \"*\" # ======================================= # Configure CORS-Filter for each service cors : allow_origin_string_match : - safe_regex : google_re2 : {} regex : \\* allow_methods : \"*\" allow_headers : \"*\" filter_enabled : default_value : numerator : 100 denominator : HUNDRED runtime_key : cors.www.enabled shadow_enabled : default_value : numerator : 0 denominator : HUNDRED runtime_key : cors.www.shadow_enabled routes : - match : prefix : \"/\" route : cluster : service # ======================================= http_filters : # ======================================= # Add CORS filter before Kelon inside the filter chain - name : envoy.cors typed_config : {} # ======================================= - name : envoy.ext_authz config : with_request_body : max_request_bytes : 8192 allow_partial_message : true failure_mode_allow : false grpc_service : google_grpc : target_uri : \"<uri to kelon>:<port under which kelon waits for envoy requests>\" stat_prefix : ext_authz timeout : 0.5s - name : envoy.router typed_config : {} clusters : - name : service connect_timeout : 0.25s type : strict_dns lb_policy : round_robin load_assignment : cluster_name : service endpoints : - lb_endpoints : - endpoint : address : socket_address : address : <uri to your deployed service> port_value : <port of your service>","title":"CORS"},{"location":"core/integration/Kelon-Envoy/#authentication-auth0-jwks","text":"If you want to keep Authorization as well as Authentication completely away from your services, you can also add Envoy's JWT-Auth-Filter to your filter chain. With this setup all of your services can completely focus on their main task... and this is business-logic and not authenticating or authorizing it! Following Config of envoy shows how to include Envoy's JWT-Auth-Filter: admin : access_log_path : \"/dev/null\" address : socket_address : address : 0.0.0.0 port_value : 8001 static_resources : listeners : - address : socket_address : address : 0.0.0.0 port_value : 8000 filter_chains : - filters : - name : envoy.http_connection_manager typed_config : \"@type\" : type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager codec_type : auto stat_prefix : ingress_http route_config : name : local_route virtual_hosts : - name : backend domains : - \"*\" cors : allow_origin_string_match : - safe_regex : google_re2 : {} regex : \\* allow_methods : \"*\" allow_headers : \"*\" filter_enabled : default_value : numerator : 100 denominator : HUNDRED runtime_key : cors.www.enabled shadow_enabled : default_value : numerator : 0 denominator : HUNDRED runtime_key : cors.www.shadow_enabled routes : - match : prefix : \"/\" route : cluster : service http_filters : - name : envoy.cors typed_config : {} # ======================================= # Add and configure JWT-Auth-Filter - name : envoy.filters.http.jwt_authn config : providers : provider1 : issuer : <issuer of your tokens. i.e. https://dev-kelon.eu.auth0.com/> remote_jwks : http_uri : uri : <uri where to fetch public keys from. i.e. https://dev-kelon.eu.auth0.com/.well-known/jwks.json> cluster : auth0 timeout : seconds : 5 rules : # Completely ignore health checks for authentication - match : prefix : /health - match : # Completely ignore login for authentication prefix : /api/login # Authenticate all requests against /api/apps - match : prefix : /api/apps requires : provider_name : provider1 # ======================================= - name : envoy.ext_authz config : with_request_body : max_request_bytes : 8192 allow_partial_message : true failure_mode_allow : false grpc_service : google_grpc : target_uri : \"<uri to kelon>:<port under which kelon waits for envoy requests>\" stat_prefix : ext_authz timeout : 0.5s - name : envoy.router typed_config : {} clusters : - name : service connect_timeout : 0.25s type : strict_dns lb_policy : round_robin load_assignment : cluster_name : service endpoints : - lb_endpoints : - endpoint : address : socket_address : address : <uri to your deployed service> port_value : <port of your service> # ======================================= # You also have to specify a cluster which describes the authentication endpoint - name : auth0 connect_timeout : 0.25s type : strict_dns lb_policy : round_robin load_assignment : cluster_name : auth0 endpoints : - lb_endpoints : - endpoint : address : socket_address : address : <uri to your auth provider. i.e. dev-kelon.eu.auth0.com> port_value : 443 transport_socket : name : envoy.transport_sockets.tls typed_config : \"@type\" : type.googleapis.com/envoy.api.v2.auth.UpstreamTlsContext common_tls_context : validation_context : trusted_ca : filename : \"/etc/ssl/certs/ca-certificates.crt\" sni : <server name indication of your auth provider. i.e. dev-kelon.eu.auth0.com>","title":"Authentication (Auth0 &amp; JWKS)"},{"location":"core/integration/Kelon-Gloo/","text":"","title":"Kelon Gloo"},{"location":"core/integration/Kelon-Istio/","text":"Work in progress We are currently implementing the Istio-Mixer-Out-of-Tree-Adapter which is closed to being finished but not working yet! Please track our next release for its completion!","title":"Kelon and Istio"},{"location":"core/integration/Kelon-Istio/#work-in-progress","text":"We are currently implementing the Istio-Mixer-Out-of-Tree-Adapter which is closed to being finished but not working yet! Please track our next release for its completion!","title":"Work in progress"},{"location":"core/integration/Services-And-Kelon/","text":"Kelon and services To integrate Kelon with your service you basically have two options Add middleware-code to your service which intercepts calls and sends them to Kelon for authorization Hook Kelon into a Proxy like Envoy which takes all incoming traffic, authorizes it agains Kelon and then forwards it to your service Writing your own request interceptor The core thing that each interceptor for Kelon needs to do is to gather all information about the incoming request and send it via a HTTP-POST to kelon for authorization (no mather which framework or programming language you want to use) A possible call to Kelon for an incoming GET /api/apps/1 might look like this: POST http://{Path to kelon}:{Port of kelon}/v1/data/allow { \"input\" : { \"method\" : \"GET\" , \"path\" : \"/api/apps/1\" , \"token\" : \"<JWT-Token from request header>\" } } Please note that the only required fields inside the input object are method and path ! All other fields can be added as you like and are available inside your policies by accessing them with i.e. data.input.token . Kelon's response to this requests can be one of following: Commuicate via Content Without any addidional flag Kelon sends a response with code 201 and a JSON body with following format: { \"Result\" : true / false } In case of any malformed input or a missing mapping for the sent path, Kelon responds with a status code other than 201. Commuicate via Status Code When you configure Kelon with the flag --respond-with-status-code it sends communicates the final decision via status codes (201/503 / Allow/Forbidden). Already existing interceptors for frameworks Due to the fact that Kelon is compatible with OPA's Data-API, every solution written for the Open Policy Agent also works for kelon. There fore it is always advisable to have a look at the official OPA-contrib repository first. Please note that you may have to change the data format which is used to post the data to Kelon! Spring Boot You can find an already existing implementation of an AccessDecisionVoter which can easily be integrated into existing Spring applicaitons here . Please note that you may have to change the data format which is used to post the data to Kelon! Dart There is also an implementation for Dart applications . Please note that you may have to change the data format which is used to post the data to Kelon! Golang An example with golang is avaliable here . Please note that you may have to change the data format which is used to post the data to Kelon! Python An example with python can be found here . Please note that you may have to change the data format which is used to post the data to Kelon!","title":"Services and Kelon"},{"location":"core/integration/Services-And-Kelon/#kelon-and-services","text":"To integrate Kelon with your service you basically have two options Add middleware-code to your service which intercepts calls and sends them to Kelon for authorization Hook Kelon into a Proxy like Envoy which takes all incoming traffic, authorizes it agains Kelon and then forwards it to your service","title":"Kelon and services"},{"location":"core/integration/Services-And-Kelon/#writing-your-own-request-interceptor","text":"The core thing that each interceptor for Kelon needs to do is to gather all information about the incoming request and send it via a HTTP-POST to kelon for authorization (no mather which framework or programming language you want to use) A possible call to Kelon for an incoming GET /api/apps/1 might look like this: POST http://{Path to kelon}:{Port of kelon}/v1/data/allow { \"input\" : { \"method\" : \"GET\" , \"path\" : \"/api/apps/1\" , \"token\" : \"<JWT-Token from request header>\" } } Please note that the only required fields inside the input object are method and path ! All other fields can be added as you like and are available inside your policies by accessing them with i.e. data.input.token . Kelon's response to this requests can be one of following:","title":"Writing your own request interceptor"},{"location":"core/integration/Services-And-Kelon/#commuicate-via-content","text":"Without any addidional flag Kelon sends a response with code 201 and a JSON body with following format: { \"Result\" : true / false } In case of any malformed input or a missing mapping for the sent path, Kelon responds with a status code other than 201.","title":"Commuicate via Content"},{"location":"core/integration/Services-And-Kelon/#commuicate-via-status-code","text":"When you configure Kelon with the flag --respond-with-status-code it sends communicates the final decision via status codes (201/503 / Allow/Forbidden).","title":"Commuicate via Status Code"},{"location":"core/integration/Services-And-Kelon/#already-existing-interceptors-for-frameworks","text":"Due to the fact that Kelon is compatible with OPA's Data-API, every solution written for the Open Policy Agent also works for kelon. There fore it is always advisable to have a look at the official OPA-contrib repository first. Please note that you may have to change the data format which is used to post the data to Kelon!","title":"Already existing interceptors for frameworks"},{"location":"core/integration/Services-And-Kelon/#spring-boot","text":"You can find an already existing implementation of an AccessDecisionVoter which can easily be integrated into existing Spring applicaitons here . Please note that you may have to change the data format which is used to post the data to Kelon!","title":"Spring Boot"},{"location":"core/integration/Services-And-Kelon/#dart","text":"There is also an implementation for Dart applications . Please note that you may have to change the data format which is used to post the data to Kelon!","title":"Dart"},{"location":"core/integration/Services-And-Kelon/#golang","text":"An example with golang is avaliable here . Please note that you may have to change the data format which is used to post the data to Kelon!","title":"Golang"},{"location":"core/integration/Services-And-Kelon/#python","text":"An example with python can be found here . Please note that you may have to change the data format which is used to post the data to Kelon!","title":"Python"},{"location":"core/overview/Simple-Example/","text":"Example To get a first notion of what kelon does, we provide several example setups which all show a configuration of Kelon with three separate datastores (PostgreSQL, MySQL & MongoDB) in different environments. To demonstrate the ease of switching between datastores with kelon, all three datastores have the same data set. In the following tutorial, we will walk through all steps needed to get a project together with kelon up and running. Datamodel The datamodel is fairly simple but contains everything you will need in a more advanced setup (i.e. JOINS). MySQL & PostgreSQL: MongoDB: // Collection \"apps\" [ { id: <number>, name: <string>, stars: <number>, rights: [ { right: <string>, user: { id: <number>, name: <string>, age: <number>, friend: <string> } } ] } ] // Collection \"users\" [ { id: <number>, name: <string, age: <number>, friend: <string> } ] Example Dataset appstore.users id name age -friend 1 Arnold 73 John Connor 2 Kevin 21 Kevin 3 Anyone null Anyone appstore.apps id name stars 2 First App for everyone 1 2 Arnold's App 2 3 Famous App 5 appstore.app_rights app_id user_id right 2 1 OWNER Appstore example (Spring-Boot & Vue.js) Bored of this \"playground\" example? Then go ahead and checkout our Kelon-enabled fork of Daniel-Seifert's spring-vue-appstore which shows how to integrate kelon in a real-world szenario.","title":"Example"},{"location":"core/overview/Simple-Example/#example","text":"To get a first notion of what kelon does, we provide several example setups which all show a configuration of Kelon with three separate datastores (PostgreSQL, MySQL & MongoDB) in different environments. To demonstrate the ease of switching between datastores with kelon, all three datastores have the same data set. In the following tutorial, we will walk through all steps needed to get a project together with kelon up and running.","title":"Example"},{"location":"core/overview/Simple-Example/#datamodel","text":"The datamodel is fairly simple but contains everything you will need in a more advanced setup (i.e. JOINS). MySQL & PostgreSQL: MongoDB: // Collection \"apps\" [ { id: <number>, name: <string>, stars: <number>, rights: [ { right: <string>, user: { id: <number>, name: <string>, age: <number>, friend: <string> } } ] } ] // Collection \"users\" [ { id: <number>, name: <string, age: <number>, friend: <string> } ]","title":"Datamodel"},{"location":"core/overview/Simple-Example/#example-dataset","text":"","title":"Example Dataset"},{"location":"core/overview/Simple-Example/#appstoreusers","text":"id name age -friend 1 Arnold 73 John Connor 2 Kevin 21 Kevin 3 Anyone null Anyone","title":"appstore.users"},{"location":"core/overview/Simple-Example/#appstoreapps","text":"id name stars 2 First App for everyone 1 2 Arnold's App 2 3 Famous App 5","title":"appstore.apps"},{"location":"core/overview/Simple-Example/#appstoreapp_rights","text":"app_id user_id right 2 1 OWNER","title":"appstore.app_rights"},{"location":"core/overview/Simple-Example/#appstore-example-spring-boot-vuejs","text":"Bored of this \"playground\" example? Then go ahead and checkout our Kelon-enabled fork of Daniel-Seifert's spring-vue-appstore which shows how to integrate kelon in a real-world szenario.","title":"Appstore example (Spring-Boot &amp; Vue.js)"},{"location":"core/overview/example/Configure-Kelon/","text":"Configure Kelon With all the previous written policies in mind, we now have to tell Kelon how to find its way from incoming requests all the way down to . The configuration process of kelon has three basic parts: datastore.yml Configures datastore connections and their entity-schemas api.yml Mappings from incomin requests to a query fired against all policies inside a package opa.yml Configuration for the internally running Open Policy Agent datastore.yml In order to enable Kelon to connect to your datastores, you need to configure the connections as well as the internal entity-structure of all your datastores inside the datastore.yml config. # Datastores to connect to datastores : mysql : type : mysql connection : host : localhost # (mysql in case of the docker-compose example) port : 3306 database : appstore user : You password : SuperSecure pg : type : postgres connection : host : localhost # (postgres in case of the docker-compose example) port : 5432 database : appstore user : You password : SuperSecure sslmode : disable mongo : type : mongo connection : host : localhost # (mongo in case of the docker-compose example) port : 27017 database : appstore user : You password : SuperSecure # Entity-Schemas define the structure of the entities of one schema inside a datastore entity_schemas : mysql : appstore : entities : - name : users - name : app_rights - name : apps - name : app_tags - name : tags pg : appstore : entities : - name : users - name : app_rights - name : apps - name : app_tags - name : tags mongo : appstore : entities : - name : users - name : apps entities : - name : rights entities : - name : user alias : users While the definition of an entity_schema for a SQL-Datastore is straight forward (Just list all entities of each datastore), creating a entity_schema for a No-SQL-Datastore (like MongoDB) ist a bit more difficult. Here you need to map the Structure of your nested entities so that Kelon can use this nested structure to find the right query-path inside your No-SQL-Datastore when joining entities inside your policies. There is also the possibility to add more connection options for each datastore or use environment variables as yaml values. Please see the Operations Guide for more information. api.yml In the end all your services, which you want to secure with Kelon, receive client requests to a lot of different endpoints. To tell Kelon which policy it should use for which endpoint, you need to create the api.yml config. Inside this configuration you can define all your different APIs which will ultimately route a incoming request (Method, Path, Body) to a OPA-Package and Datastore. apis : # Route all requests starting with /api/mysql to MySQL - path-prefix : /api/mysql datastore : mysql mappings : - path : /apps/.* package : applications.mysql # Route all requests starting with /api/mongo to MongoDB - path-prefix : /api/mongo datastore : mongo mappings : - path : /apps/.* package : applications.mongo # All other requests are routed to PostgreSQL - path-prefix : /api/postgres datastore : pg mappings : - path : /apps/.* package : applications.pg call-operands A core feature of Kelon is to map the result of OPA's partial evaluated policies to native datastore queries. To keep the adoption to different datastore-platforms as flexible as possible, all builtin call operands from the OPA's Policy-Language are mapped via mappings-files which are located in the call-operands directory. Each mapping file is used for one datastory type and is therefore named with the pattern call-operands/{datastore-type}.yml . call-operands/mysql.yml & call-operands/postgres.yml Each internal function essentially consists of a operator (op) and its arguments. To map this function to a datastore-native query function, you need to define the original functions-operator and the amount of expected arguments as well as the resulting mapping inside the native query. call-operands : # Mathematical operands # ... # Relational operands - op : eq args : 2 mapping : \"$0 = $1\" - op : equal args : 2 mapping : \"$0 = $1\" - op : neq args : 2 mapping : \"$0 != $1\" - op : lt args : 2 mapping : \"$0 < $1\" - op : gt args : 2 mapping : \"$0 > $1\" - op : lte args : 2 mapping : \"$0 <= $1\" - op : gte args : 2 mapping : \"$0 >= $1\" # Mathematical Functions # ... Let's take the mapping gte from above. The builtin call gte(a, b) will be mapped to a >= b inside your native SQL-Query. call-operands/mongo.yml call-operands : # Relational operands - op : eq args : 2 mapping : \"$0: $1\" - op : equal args : 2 mapping : \"$0: $1\" - op : neq args : 2 mapping : \"$0: { \\\"$ne\\\": $1 }\" - op : lt args : 2 mapping : \"$0: { \\\"$lt\\\": $1 }\" - op : gt args : 2 mapping : \"$0: { \\\"$gt\\\": $1 }\" - op : lte args : 2 mapping : \"$0: { \\\"$lte\\\": $1 }\" - op : gte args : 2 mapping : \"$0: { \\\"$gte\\\": $1 }\" opa.yml Becaues Kelon is just a wrapper around the Open Policy Agent, you can also configure the internally used OPA itself. labels : app : Kelon region : europe-west3 environment : development decision_logs : console : true reporting : min_delay_seconds : 300 max_delay_seconds : 600 default_decision : /http/authz/allow","title":"Configure Kelon"},{"location":"core/overview/example/Configure-Kelon/#configure-kelon","text":"With all the previous written policies in mind, we now have to tell Kelon how to find its way from incoming requests all the way down to . The configuration process of kelon has three basic parts: datastore.yml Configures datastore connections and their entity-schemas api.yml Mappings from incomin requests to a query fired against all policies inside a package opa.yml Configuration for the internally running Open Policy Agent","title":"Configure Kelon"},{"location":"core/overview/example/Configure-Kelon/#datastoreyml","text":"In order to enable Kelon to connect to your datastores, you need to configure the connections as well as the internal entity-structure of all your datastores inside the datastore.yml config. # Datastores to connect to datastores : mysql : type : mysql connection : host : localhost # (mysql in case of the docker-compose example) port : 3306 database : appstore user : You password : SuperSecure pg : type : postgres connection : host : localhost # (postgres in case of the docker-compose example) port : 5432 database : appstore user : You password : SuperSecure sslmode : disable mongo : type : mongo connection : host : localhost # (mongo in case of the docker-compose example) port : 27017 database : appstore user : You password : SuperSecure # Entity-Schemas define the structure of the entities of one schema inside a datastore entity_schemas : mysql : appstore : entities : - name : users - name : app_rights - name : apps - name : app_tags - name : tags pg : appstore : entities : - name : users - name : app_rights - name : apps - name : app_tags - name : tags mongo : appstore : entities : - name : users - name : apps entities : - name : rights entities : - name : user alias : users While the definition of an entity_schema for a SQL-Datastore is straight forward (Just list all entities of each datastore), creating a entity_schema for a No-SQL-Datastore (like MongoDB) ist a bit more difficult. Here you need to map the Structure of your nested entities so that Kelon can use this nested structure to find the right query-path inside your No-SQL-Datastore when joining entities inside your policies. There is also the possibility to add more connection options for each datastore or use environment variables as yaml values. Please see the Operations Guide for more information.","title":"datastore.yml"},{"location":"core/overview/example/Configure-Kelon/#apiyml","text":"In the end all your services, which you want to secure with Kelon, receive client requests to a lot of different endpoints. To tell Kelon which policy it should use for which endpoint, you need to create the api.yml config. Inside this configuration you can define all your different APIs which will ultimately route a incoming request (Method, Path, Body) to a OPA-Package and Datastore. apis : # Route all requests starting with /api/mysql to MySQL - path-prefix : /api/mysql datastore : mysql mappings : - path : /apps/.* package : applications.mysql # Route all requests starting with /api/mongo to MongoDB - path-prefix : /api/mongo datastore : mongo mappings : - path : /apps/.* package : applications.mongo # All other requests are routed to PostgreSQL - path-prefix : /api/postgres datastore : pg mappings : - path : /apps/.* package : applications.pg","title":"api.yml"},{"location":"core/overview/example/Configure-Kelon/#call-operands","text":"A core feature of Kelon is to map the result of OPA's partial evaluated policies to native datastore queries. To keep the adoption to different datastore-platforms as flexible as possible, all builtin call operands from the OPA's Policy-Language are mapped via mappings-files which are located in the call-operands directory. Each mapping file is used for one datastory type and is therefore named with the pattern call-operands/{datastore-type}.yml .","title":"call-operands"},{"location":"core/overview/example/Configure-Kelon/#call-operandsmysqlyml-call-operandspostgresyml","text":"Each internal function essentially consists of a operator (op) and its arguments. To map this function to a datastore-native query function, you need to define the original functions-operator and the amount of expected arguments as well as the resulting mapping inside the native query. call-operands : # Mathematical operands # ... # Relational operands - op : eq args : 2 mapping : \"$0 = $1\" - op : equal args : 2 mapping : \"$0 = $1\" - op : neq args : 2 mapping : \"$0 != $1\" - op : lt args : 2 mapping : \"$0 < $1\" - op : gt args : 2 mapping : \"$0 > $1\" - op : lte args : 2 mapping : \"$0 <= $1\" - op : gte args : 2 mapping : \"$0 >= $1\" # Mathematical Functions # ... Let's take the mapping gte from above. The builtin call gte(a, b) will be mapped to a >= b inside your native SQL-Query.","title":"call-operands/mysql.yml &amp; call-operands/postgres.yml"},{"location":"core/overview/example/Configure-Kelon/#call-operandsmongoyml","text":"call-operands : # Relational operands - op : eq args : 2 mapping : \"$0: $1\" - op : equal args : 2 mapping : \"$0: $1\" - op : neq args : 2 mapping : \"$0: { \\\"$ne\\\": $1 }\" - op : lt args : 2 mapping : \"$0: { \\\"$lt\\\": $1 }\" - op : gt args : 2 mapping : \"$0: { \\\"$gt\\\": $1 }\" - op : lte args : 2 mapping : \"$0: { \\\"$lte\\\": $1 }\" - op : gte args : 2 mapping : \"$0: { \\\"$gte\\\": $1 }\"","title":"call-operands/mongo.yml"},{"location":"core/overview/example/Configure-Kelon/#opayml","text":"Becaues Kelon is just a wrapper around the Open Policy Agent, you can also configure the internally used OPA itself. labels : app : Kelon region : europe-west3 environment : development decision_logs : console : true reporting : min_delay_seconds : 300 max_delay_seconds : 600 default_decision : /http/authz/allow","title":"opa.yml"},{"location":"core/overview/example/Create-Policies/","text":"Create Policies In order to enable Kelon to make decisions on incoming requests, you have to write policies in OPA's own Policy-Language which you can put in different Rego-Files. To keep your policies organized, you can define a package per Rego-File which is also the central way to address all policies inside this package. As a result of that you should keep your package-names clean and in some way connected to the API you want to secure with Kelon. For this example we want to create four simple policies which show all basic capabilities of kelon: Users with right 'OWNER' on app can access it always Endpoint: GET /api/{datastore-alias}/apps/:app_id All apps with 5 stars are public Endpoint: GET /api/{datastore-alias}/apps/:app_id The first app is public Endpoint: GET /api/{datastore-alias}/apps/:app_id All users that are a friends of Kevin are allowed see everything Endpoint: GET /api/{datastore-alias}/* SQL policies/mysql_applications.rego The file policies/pg_applications.rego has almost the same content. The only difference is that each \"mysql\" is replaced by a \"pg\" (which only occurs, because of this simple szenario). package applications.mysql # Deny all by default allow = false # Path: GET /api/mysql/apps/:app_id # Users with right 'OWNER' on app can access it always allow = true { some appId, u, r input.method == \"GET\" input.path = [\"api\", \"mysql\", \"apps\", appId] # Join data.mysql.users[u].id == data.mysql.app_rights[r].user_id # Where u.name == input.user r.right == \"OWNER\" r.app_id == appId } # Path: GET /api/mysql/apps/:app_id # All apps with 5 stars are public allow = true { some app, appId input.method == \"GET\" input.path = [\"api\", \"mysql\", \"apps\", appId] data.mysql.apps[app].id == appId app.stars == 5 } # Path: GET /api/mysql/apps/:app_id # The first app is public allow = true { input.method == \"GET\" input.path == [\"api\", \"mysql\", \"apps\", \"1\"] } # Path: GET <any> # All users that are a friends of Kevin are allowed see everything allow = true { some user input.method == \"GET\" # Query data.mysql.users[user].name == input.user user.friend == \"Kevin\" } With a closer look at the first policy in the above Rego you will notice, that the data inside the tables of your datastore can be 'magically' accessed inside Regos with the following Syntax: data.{datastore-alias}.{entity}.{column} Additianally the join between the table users and app_rights on the condition users.id == app_rights.user_id is done with the statements data.mysql.users[u].id == data.mysql.app_rights[r].user_id u.name == input.user r.right == \"OWNER\" r.app_id == appId # SELECT count(*) FROM users # INNER JOIN app_rights # ON users.id = app_rights.user_id # WHERE users.name = {input.user} # AND app_rights.right = 'OWNER' # AND app_rights.app_id = {appId} No-SQL policies/mongo_applications.rego Writing policies for No-SQL datastores is nearly the same as writing them for SQL-Datastores. You can just write a join (as if it was for a SQL-Datastore) which is translated by kelon using your configured entity_schema The only difference to writing policies in comparison to SQL-Datastores is: The first entity of your policy must be the the collection (in case of MongoDB) you want to address The Join-Condition is ignored (You still have to add any condition for now...) package applications.mongo # Deny all by default allow = false # Path: GET /api/mongo/apps/:app_id # Users with right 'OWNER' on app can access it always allow = true { input.method == \"GET\" input.path = [\"api\", \"mongo\", \"apps\", appId] # This query fires against collection -> apps data.mongo.apps[app].id == appId # Nest elements data.mongo.rights[right].id == app.id data.mongo.users[user].id == right.id # Query root app.stars > 2 # Query nested right.right == \"OWNER\" user.name == input.user } ... Common policy patterns Following examples show basic policy patterns which you can use to write your policies Join single entity # Datastore-Alias: mysql # Table-Join: users -> app_rights data.mysql.users[user].id == data.mysql.app_rights[appRight].user_id Join multiple entities # Datastore-Alias: mysql # Table-Join: users -> app_rights -> apps data.mysql.users[user].id == data.mysql.app_rights[appRight].user_id data.mysql.apps[app].id == appRights.app_id Self-Join Self-Join is currently not supported by Kelon!","title":"Create Policies"},{"location":"core/overview/example/Create-Policies/#create-policies","text":"In order to enable Kelon to make decisions on incoming requests, you have to write policies in OPA's own Policy-Language which you can put in different Rego-Files. To keep your policies organized, you can define a package per Rego-File which is also the central way to address all policies inside this package. As a result of that you should keep your package-names clean and in some way connected to the API you want to secure with Kelon. For this example we want to create four simple policies which show all basic capabilities of kelon: Users with right 'OWNER' on app can access it always Endpoint: GET /api/{datastore-alias}/apps/:app_id All apps with 5 stars are public Endpoint: GET /api/{datastore-alias}/apps/:app_id The first app is public Endpoint: GET /api/{datastore-alias}/apps/:app_id All users that are a friends of Kevin are allowed see everything Endpoint: GET /api/{datastore-alias}/*","title":"Create Policies"},{"location":"core/overview/example/Create-Policies/#sql","text":"","title":"SQL"},{"location":"core/overview/example/Create-Policies/#policiesmysql_applicationsrego","text":"The file policies/pg_applications.rego has almost the same content. The only difference is that each \"mysql\" is replaced by a \"pg\" (which only occurs, because of this simple szenario). package applications.mysql # Deny all by default allow = false # Path: GET /api/mysql/apps/:app_id # Users with right 'OWNER' on app can access it always allow = true { some appId, u, r input.method == \"GET\" input.path = [\"api\", \"mysql\", \"apps\", appId] # Join data.mysql.users[u].id == data.mysql.app_rights[r].user_id # Where u.name == input.user r.right == \"OWNER\" r.app_id == appId } # Path: GET /api/mysql/apps/:app_id # All apps with 5 stars are public allow = true { some app, appId input.method == \"GET\" input.path = [\"api\", \"mysql\", \"apps\", appId] data.mysql.apps[app].id == appId app.stars == 5 } # Path: GET /api/mysql/apps/:app_id # The first app is public allow = true { input.method == \"GET\" input.path == [\"api\", \"mysql\", \"apps\", \"1\"] } # Path: GET <any> # All users that are a friends of Kevin are allowed see everything allow = true { some user input.method == \"GET\" # Query data.mysql.users[user].name == input.user user.friend == \"Kevin\" } With a closer look at the first policy in the above Rego you will notice, that the data inside the tables of your datastore can be 'magically' accessed inside Regos with the following Syntax: data.{datastore-alias}.{entity}.{column} Additianally the join between the table users and app_rights on the condition users.id == app_rights.user_id is done with the statements data.mysql.users[u].id == data.mysql.app_rights[r].user_id u.name == input.user r.right == \"OWNER\" r.app_id == appId # SELECT count(*) FROM users # INNER JOIN app_rights # ON users.id = app_rights.user_id # WHERE users.name = {input.user} # AND app_rights.right = 'OWNER' # AND app_rights.app_id = {appId}","title":"policies/mysql_applications.rego"},{"location":"core/overview/example/Create-Policies/#no-sql","text":"","title":"No-SQL"},{"location":"core/overview/example/Create-Policies/#policiesmongo_applicationsrego","text":"Writing policies for No-SQL datastores is nearly the same as writing them for SQL-Datastores. You can just write a join (as if it was for a SQL-Datastore) which is translated by kelon using your configured entity_schema The only difference to writing policies in comparison to SQL-Datastores is: The first entity of your policy must be the the collection (in case of MongoDB) you want to address The Join-Condition is ignored (You still have to add any condition for now...) package applications.mongo # Deny all by default allow = false # Path: GET /api/mongo/apps/:app_id # Users with right 'OWNER' on app can access it always allow = true { input.method == \"GET\" input.path = [\"api\", \"mongo\", \"apps\", appId] # This query fires against collection -> apps data.mongo.apps[app].id == appId # Nest elements data.mongo.rights[right].id == app.id data.mongo.users[user].id == right.id # Query root app.stars > 2 # Query nested right.right == \"OWNER\" user.name == input.user } ...","title":"policies/mongo_applications.rego"},{"location":"core/overview/example/Create-Policies/#common-policy-patterns","text":"Following examples show basic policy patterns which you can use to write your policies","title":"Common policy patterns"},{"location":"core/overview/example/Create-Policies/#join-single-entity","text":"# Datastore-Alias: mysql # Table-Join: users -> app_rights data.mysql.users[user].id == data.mysql.app_rights[appRight].user_id","title":"Join single entity"},{"location":"core/overview/example/Create-Policies/#join-multiple-entities","text":"# Datastore-Alias: mysql # Table-Join: users -> app_rights -> apps data.mysql.users[user].id == data.mysql.app_rights[appRight].user_id data.mysql.apps[app].id == appRights.app_id","title":"Join multiple entities"},{"location":"core/overview/example/Create-Policies/#self-join","text":"Self-Join is currently not supported by Kelon!","title":"Self-Join"},{"location":"core/overview/example/Run-Example/","text":"Run the example Install kelon (not needed if you want to use the docker-comopose file from the example) From source # Clone the repository $ git clone git@github.com:Foundato/kelon.git # Build the container $ docker build . -t kelon:latest # Or install kelon on your local machine $ go mod download $ go build -o ./kelon ./cmd/kelon Docker image $ docker pull kelonio/kelon $ docker run kelonio/kelon --help Start the environment The entire example environment can be started with the provided docker-compose in the project's root directory with following command $ docker-compose up -d This will start following components: Kelon Port: 8181 MySQL Port: 3306 PostgreSQL Port: 5432 MongoDB Port: 27017-27019 After all containers are built and up, you can verify that everything is up by performing a valid request: to PostgreSQL $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } to MySQL $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/mysql/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } to MongoDB $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/mongo/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } Play around You now have a complete setup of Kelon which you can use to play around. You can i.e. try to access an app you shouldn't be allowed to: $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/2\", \"user\": \"Anyone\"}}' > { \"result\" :false } Or access an app with 5 stars (which the user 'Anyone' is allowed to): $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/3\", \"user\": \"Anyone\"}}' > { \"result\" :true } There is also a POSTMAN-COLLECTION in the example directory which contains a bunch of queries agains all three datasources (PostgreSQL, MySQL, MongoDB). Feel free to play around with the existing regos and databases to get a feeling of how to write policies and configure Kelon. Good to know Due to Kelon's hot reloading of policies , you can edit the policies which are mounted into the Docker-Container and directly see the result of your work within seconds. Please also check the Container-Logs. If you make any mistake while writing your policies, Kelon will let you know. Clean up After you are done, just stop the entire setup by running: $ docker-compose down","title":"Run the example"},{"location":"core/overview/example/Run-Example/#run-the-example","text":"","title":"Run the example"},{"location":"core/overview/example/Run-Example/#install-kelon","text":"(not needed if you want to use the docker-comopose file from the example)","title":"Install kelon"},{"location":"core/overview/example/Run-Example/#from-source","text":"# Clone the repository $ git clone git@github.com:Foundato/kelon.git # Build the container $ docker build . -t kelon:latest # Or install kelon on your local machine $ go mod download $ go build -o ./kelon ./cmd/kelon","title":"From source"},{"location":"core/overview/example/Run-Example/#docker-image","text":"$ docker pull kelonio/kelon $ docker run kelonio/kelon --help","title":"Docker image"},{"location":"core/overview/example/Run-Example/#start-the-environment","text":"The entire example environment can be started with the provided docker-compose in the project's root directory with following command $ docker-compose up -d This will start following components: Kelon Port: 8181 MySQL Port: 3306 PostgreSQL Port: 5432 MongoDB Port: 27017-27019 After all containers are built and up, you can verify that everything is up by performing a valid request: to PostgreSQL $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } to MySQL $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/mysql/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true } to MongoDB $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/mongo/apps/2\", \"user\": \"Arnold\"}}' > { \"result\" :true }","title":"Start the environment"},{"location":"core/overview/example/Run-Example/#play-around","text":"You now have a complete setup of Kelon which you can use to play around. You can i.e. try to access an app you shouldn't be allowed to: $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/2\", \"user\": \"Anyone\"}}' > { \"result\" :false } Or access an app with 5 stars (which the user 'Anyone' is allowed to): $ curl --request POST \\ --url http://localhost:8181/v1/data \\ --header 'Content-Type: application/json' \\ --data '{\"input\": {\"method\": \"GET\", \"path\": \"/api/pg/apps/3\", \"user\": \"Anyone\"}}' > { \"result\" :true } There is also a POSTMAN-COLLECTION in the example directory which contains a bunch of queries agains all three datasources (PostgreSQL, MySQL, MongoDB). Feel free to play around with the existing regos and databases to get a feeling of how to write policies and configure Kelon.","title":"Play around"},{"location":"core/overview/example/Run-Example/#good-to-know","text":"Due to Kelon's hot reloading of policies , you can edit the policies which are mounted into the Docker-Container and directly see the result of your work within seconds. Please also check the Container-Logs. If you make any mistake while writing your policies, Kelon will let you know.","title":"Good to know"},{"location":"core/overview/example/Run-Example/#clean-up","text":"After you are done, just stop the entire setup by running: $ docker-compose down","title":"Clean up"},{"location":"core/philosophy/What-Is-A-Policy/","text":"What is a policy","title":"What is a Policy"},{"location":"core/philosophy/What-Is-A-Policy/#what-is-a-policy","text":"","title":"What is a policy"},{"location":"core/philosophy/Why-External-Policy-Enforcement/","text":"Why external policy enforcement In modern software development where terms like 'Microservices' and 'Agile' rule almost every Kick-Off-Meeting, the need of developing large systems while keeping the teams small and language independent gets more and more important. While the idiom 'Divide And Conquer' works for the splitting of domains and development-teams, splitting up central processes like authorization won't work with this approach. Implementing authorization policies into each microservice will quickly end in a large pile of different services all implementing (or maybe not implementing) parts of the previously defined business rules. This may become even more difficult if you want to enforce global policies throughout your entire system. Therefore external-policy-enforcement and with it the Open Policy Agent (OPA) has arisen in the Open-Source Community. The OPA-Way of enforcing policies is by implementing and also testing all your business-rules in one single component (The Open Policy Agent) and make your services query it for permission on any incoming user request. As a result your services become dumb (in terms of authorization) which makes them easier to implement. On the other hand the enforcement of your policies becomes much more transparent and easier to test and review because all your policies are stored in one place.","title":"Why external Policy Enforcement"},{"location":"core/philosophy/Why-External-Policy-Enforcement/#why-external-policy-enforcement","text":"In modern software development where terms like 'Microservices' and 'Agile' rule almost every Kick-Off-Meeting, the need of developing large systems while keeping the teams small and language independent gets more and more important. While the idiom 'Divide And Conquer' works for the splitting of domains and development-teams, splitting up central processes like authorization won't work with this approach. Implementing authorization policies into each microservice will quickly end in a large pile of different services all implementing (or maybe not implementing) parts of the previously defined business rules. This may become even more difficult if you want to enforce global policies throughout your entire system. Therefore external-policy-enforcement and with it the Open Policy Agent (OPA) has arisen in the Open-Source Community. The OPA-Way of enforcing policies is by implementing and also testing all your business-rules in one single component (The Open Policy Agent) and make your services query it for permission on any incoming user request. As a result your services become dumb (in terms of authorization) which makes them easier to implement. On the other hand the enforcement of your policies becomes much more transparent and easier to test and review because all your policies are stored in one place.","title":"Why external policy enforcement"},{"location":"kelon/Initial-Exploration/","text":"Introduction To get a better understanding of how kelon is built, have a look at following infographics to get a better understanding of the surrounding environment of Kelon. External interfaces Request flow Interface usage exploration In order to intercept each request in your backend and send it to Kelon, you have to implement some kind of middleware in your backend. All big backend-frameworks contain middleware-APIs which help you to write this interception with only a view lines of code. Following interface usage exploration lists a view common frameworks and their authorization-middleware components. Note the two different approaches of implementing the authorization-middleware (either by having one interceptor which sends all incoming requests to kelon or multiple interceptors). We strongly recommend you to only use one interceptor!","title":"Introduction"},{"location":"kelon/Initial-Exploration/#introduction","text":"To get a better understanding of how kelon is built, have a look at following infographics to get a better understanding of the surrounding environment of Kelon.","title":"Introduction"},{"location":"kelon/Initial-Exploration/#external-interfaces","text":"","title":"External interfaces"},{"location":"kelon/Initial-Exploration/#request-flow","text":"","title":"Request flow"},{"location":"kelon/Initial-Exploration/#interface-usage-exploration","text":"In order to intercept each request in your backend and send it to Kelon, you have to implement some kind of middleware in your backend. All big backend-frameworks contain middleware-APIs which help you to write this interception with only a view lines of code. Following interface usage exploration lists a view common frameworks and their authorization-middleware components. Note the two different approaches of implementing the authorization-middleware (either by having one interceptor which sends all incoming requests to kelon or multiple interceptors). We strongly recommend you to only use one interceptor!","title":"Interface usage exploration"},{"location":"kelon/architecture/Request-Mapping/","text":"Request mapping Each incoming request to the backend has to be intercepted and wrapped in a JSON-object called \"input\". This object has to contain all important information about the incoming request like 'method', 'path' and i.e. 'authorization'. Kelon takes the input-object, adds more information to it and compiles it with the Open Policy Agent. This means you also have access to i.e. Query-Parameters a client sent to your backend inside your Regos!","title":"Request mapping"},{"location":"kelon/architecture/Request-Mapping/#request-mapping","text":"Each incoming request to the backend has to be intercepted and wrapped in a JSON-object called \"input\". This object has to contain all important information about the incoming request like 'method', 'path' and i.e. 'authorization'. Kelon takes the input-object, adds more information to it and compiles it with the Open Policy Agent. This means you also have access to i.e. Query-Parameters a client sent to your backend inside your Regos!","title":"Request mapping"},{"location":"operations/APIs/","text":"APIs","title":"APIs"},{"location":"operations/APIs/#apis","text":"","title":"APIs"},{"location":"operations/Configuration/","text":"Configuration Kelon (CLI) Kelon already comes with a CLI. Just type kelon --help after you installed it. usage: kelon [<flags>] <command> [<args> ...] Kelon policy enforcer. Flags: -h, --help Show context-sensitive help (also try --help-long and --help-man). -d, --datastore-conf=./datastore.yml Path to the datastore configuration yaml. -a, --api-conf=./api.yml Path to the api configuration yaml. --config-watcher-path=CONFIG-WATCHER-PATH Path where the config watcher should listen for changes. -o, --opa-conf=./opa.yml Path to the OPA configuration yaml. -r, --rego-dir=REGO-DIR Dir containing .rego files which will be loaded into OPA. --path-prefix=\"/v1\" Prefix which is used to proxy OPA's Data-API. -p, --port=8181 Port on which the proxy endpoint is served. --preprocess-policies Preprocess incoming policies for internal use-case (EXPERIMENTAL FEATURE! DO NOT USE!). --log-level=INFO Log-Level for Kelon. Must be one of [DEBUG, INFO, WARN, ERROR] --respond-with-status-code Communicate Decision via status code 200 (ALLOW) or 403 (DENY). --envoy-port=ENVOY-PORT Also start Envoy GRPC-Proxy on specified port so integrate kelon with Istio. --envoy-dry-run Enable/Disable the dry run feature of the envoy-proxy. --envoy-reflection Enable/Disable the reflection feature of the envoy-proxy. --istio-port=ISTIO-PORT Also start Istio Mixer Out of Tree Adapter on specified port so integrate kelon with Istio. --istio-credential-file=ISTIO-CREDENTIAL-FILE Filepath containing istio credentials for mTLS (i.e. adapter.crt). --istio-private-key-file=ISTIO-PRIVATE-KEY-FILE Filepath containing istio private key for mTLS (i.e. adapter.key). --istio-certificate-file=ISTIO-CERTIFICATE-FILE Filepath containing istio certificate for mTLS (i.e. ca.pem). --telemetry-service=TELEMETRY-SERVICE Service that is used for telemetry [Prometheus, ApplicationInsights] --instrumentation-key=INSTRUMENTATION-KEY The ApplicationInsights-InstrumentationKey that is used to connect to the API. --application-insights-service-name=\"Kelon\" The name which will be displayed for kelon inside application insights. --application-insights-max-batch-size=8192 Configure how many items can be sent in one call to the data collector. --application-insights-max-batch-interval-seconds=2 Configure the maximum delay before sending queued telemetry. --application-insights-log-levels=\"fatal,panic,error,warn\" Configure log levels which are sent. Allowed values are [fatal, panic, error, warn, info, debug, trace] --application-insights-stats-interval-seconds=5 Interval in seconds in which system stats are measured and sent. --version Show application version. Commands: help [<command>...] Show help. run Run kelon in production mode. In addition to that Kelon provides the possibility to be configured via environment variables. This may be handy if you want to run it inside a container. General Flag Short Environment Default Type --datastore-conf -d DATASTORE_CONF ./datastore.yml Existing File --api-conf -a API_CONF ./api.yml Existing File --config-watcher-path CONFIG_WATCHER_PATH ./policies Existing Dir --opa-conf -o OPA_CONF ./opa.yml Existing File --rego-dir -r REGO_DIR ./policies Existing Dir --path-prefix PATH_PREFIX /v1 String --port -p PORT 8181 Number --preprocess-policies PREPROCESS_POLICIES false Boolean --respond-with-status-code RESPOND_WITH_STATUS_CODE false Boolean Envoy Flag Short Environment Default Type --envoy-port ENVOY_PORT Number --envoy-dry-run ENVOY_DRY_RUN false Boolean --envoy-reflection ENVOY_REFLECTION false Boolean Istio Flag Short Environment Default Type --istio-port ISTIO_PORT Number --istio-credential-file ISTIO_CREDENTIAL_FILE Existing File --istio-private-key-file ISTIO_PRIVATE_KEY_FILE Existing File --istio-certificate-file ISTIO_CERTIFICATE_FILE Existing File Telemetry Flag Short Environment Default Type --telemetry-service TELEMETRY_SERVICE Enum Application Insights When you have set ApplicationInsights as --telemetry-service Flag Short Environment Default Type --instrumentation-key INSTRUMENTATION_KEY String --application-insights-service-name APPLICATION_INSIGHTS_SERVICE_NAME Kelon String --application-insights-max-batch-size APPLICATION_INSIGHTS_MAX_BATCH_SIZE 8192 Number --application-insights-max-batch-interval-seconds APPLICATION_INSIGHTS_MAX_BATCH_INTERVAL_SECONDS 2 Number --application-insights-log-levels APPLICATION_INSIGHTS_LOG_LEVELS fatal,panic,error,warn Enum-List --application-insights-stats-interval-seconds APPLICATION_INSIGHTS_STATS_INTERVAL_SECONDS 5 Number datastore.yml The datastore.yml defines all available datastores and their entities. # List of all datastores which kelon should be able to connect to # Each datastore has to have an entity schema configured! datastores : # Datastore's alias (it will be used throughout all your policies). mysql : # Datastore type # Kelon supports [mysql, postgres, mongo] [ type : <string> ] # Properties that are needed to connect to the datastore connection : # Hostname or IP of the database [ host : <string> ] # Port under which the database is available [ port : <int> ] # Name of the database to connect to # Many database servers run multiple databases. # In this case create one datastore for each database [ database : <string> ] # The user which is used for the database connection [ user : <string> ] # The password of the user [ password : <string> ] # Connection options for the database connection # To get all available options for your database, see section \"Connection options\" below [ <option> : <string> ] # Metadata attached to the datastore metadata : # Only used from SQL-Datastores # Sets max idle connections of the database connection pool [ maxIdleConnections : <int> ] # Only used from SQL-Datastores # Sets max open connections of the database connection pool [ maxOpenConnections : <int> ] # Only used from SQL-Datastores # Sets max lifetime of each connection inside the database connection pool [ connectionMaxLifetimeSeconds : <int> ] # Only used if ApplicationInsights is set as Telemetry-Service! # Sets the name of the Dependency which is traced for this datastore [ telemetryName : <string> ] # Only used if ApplicationInsights is set as Telemetry-Service! # Sets the type of the Dependency which is traced for this datastore [ telemetryType : <string> ] # Entity-Schemas define the entities of one schema inside a datastore. # An entity_schema has several purposes: # => Help kelon to detect misspellings in regos # => Create entity-aliases for complex table-names # => Define the structure of nested entities (Just for No-SQL DBs) entity_schemas : # Datastore's alias # This example shows how each SQL-Datastore should be configured. mysql : # Schema name # Kelon automatically adds the schema name to entities # This means that 'data.mysql.users' inside a rego will be translated # to 'appstore.users' in the resulting SQL-Statement. # # !!! The entities inside all schemas of one Datastore have to be disjunct !!! # Otherwise kelon will fail on startup appstore : # List of all entities of schema 'appstore' entities : # Entity with the name inside the datastore - [ name : <string> ] # And an optional alias (used inside regos) [ alias : <string> | optional ] # This example shows how each No-SQL-Datastore should be configured. mongo : # Schema name # Because No-SQL-Datastores don't have concept for schemas, # Kelon ignores the schema name for i.e. a MongoDB. # # !!! The entities inside all schemas of one Datastore have to be disjunct !!! # Otherwise kelon will fail on startup appstore : # List of all entities (in case of MongoDB each entity is a collection) entities : # Collection with it's name inside the datastore - [ name : <string> ] # Collection's optinal alias (used inside regos) [ alias : <string> | optional ] # Nested entities (Only supported for No-SQL-Datastores) # The depth of nesting entities is unlimited. # It makes no difference if the nested entities are arrays or objects entities : # Name of nested entity - [ name : <string> ] # Collection's optinal alias (used inside regos) [ alias : <string> | optional ] Connection options Kelon supports different databases (PostgreSQL, MySQL and MongoDB) each of them having different connection options. To keep the configuration of connection options as simple as possible, Kelon just passes all key-value-pairs of each the datastore connection (despite the dedicated ones like i.e. username, host, port, etc.) directly to the used database adapter. Following table should help to lookup all available options for each supported database: Database Used driver Options PostgreSQL github.com/lib/pq Go Docs, Connection String Parameters MySQL github.com/go-sql-driver/mysql Go Docs, DSN Parameters MongoDB go.mongodb.org/mongo-driver/mongo Mongo-Docs, Connection options Injecting environment variables Each value inside the datastore.yml file can be replaced with a string follwing the pattern ${<environment variable>} which is replaced with the value of the environment variable at startup. call-operands/{datastore-type}.yml Open Policy Agent has builtin call operands which may not be the same as the ones of each datastore. Therefore each datastore-type has to have a mapping-file inside the folder 'call-operands'. The name of each file inside this directory has to match the type of the datastore. # Call operands map OPA's functions to datastore-native ones. # You find more advanced files in directory /call-operands call-operands : # Operand name inside OPA's context - [ op : <string> ] # Number of arguments the function call should take # Used for validation [ args : <int> ] # Mapping which mappes the OPA-native call to a Datastore-native call. # This is done by defining a pattern where all occurences of $<arg-pos> # are replaced with the original argument at position <arg-pos> (zero based). [ mapping : <string> ] api.yml The datastore.yml contains all necessary configuration kelon needs to map incoming api-requests to OPA-Queries executed inside datastores. # Mappings for the APIs that your services expose apis : # API-Collection # Each collection can have a path prefix which is prepended to every API-Mapping # inside the collection. - [ path-prefix : <URL|string> ] # All rego-queries mapped by this API-collection will include # this datastore-alias as unknown. # This means that the regos this collection targets can contain # something like 'data.<datastore-alias>.<entity>.<attribute>' [ datastore : <datastore-alias|string> ] # Path-Mappings for incoming paths # (the most specific mapping is picked in case of multiple mappings) mappings : # Path-Mapping # Each mapping has to specify a path (regex) and a package which is used # by kelon to generate the target package of an mapped query. - [ path : <regex|string> ] # OPA's target package of this Path-Mapping [ package : <string> ] # HTTP-Methods this path should map (optional) # If no methods are specified, kellon will match [GET,PUT,POST,DELETE,PATCH] methods : - [ <string> ... ] opa.yml Internally used by Open Policy Agent. Klick here for more information. labels : app : Kelon region : europe-west3 environment : development decision_logs : console : true reporting : min_delay_seconds : 300 max_delay_seconds : 600 default_decision : /http/authz/allow","title":"Configuration"},{"location":"operations/Configuration/#configuration","text":"","title":"Configuration"},{"location":"operations/Configuration/#kelon-cli","text":"Kelon already comes with a CLI. Just type kelon --help after you installed it. usage: kelon [<flags>] <command> [<args> ...] Kelon policy enforcer. Flags: -h, --help Show context-sensitive help (also try --help-long and --help-man). -d, --datastore-conf=./datastore.yml Path to the datastore configuration yaml. -a, --api-conf=./api.yml Path to the api configuration yaml. --config-watcher-path=CONFIG-WATCHER-PATH Path where the config watcher should listen for changes. -o, --opa-conf=./opa.yml Path to the OPA configuration yaml. -r, --rego-dir=REGO-DIR Dir containing .rego files which will be loaded into OPA. --path-prefix=\"/v1\" Prefix which is used to proxy OPA's Data-API. -p, --port=8181 Port on which the proxy endpoint is served. --preprocess-policies Preprocess incoming policies for internal use-case (EXPERIMENTAL FEATURE! DO NOT USE!). --log-level=INFO Log-Level for Kelon. Must be one of [DEBUG, INFO, WARN, ERROR] --respond-with-status-code Communicate Decision via status code 200 (ALLOW) or 403 (DENY). --envoy-port=ENVOY-PORT Also start Envoy GRPC-Proxy on specified port so integrate kelon with Istio. --envoy-dry-run Enable/Disable the dry run feature of the envoy-proxy. --envoy-reflection Enable/Disable the reflection feature of the envoy-proxy. --istio-port=ISTIO-PORT Also start Istio Mixer Out of Tree Adapter on specified port so integrate kelon with Istio. --istio-credential-file=ISTIO-CREDENTIAL-FILE Filepath containing istio credentials for mTLS (i.e. adapter.crt). --istio-private-key-file=ISTIO-PRIVATE-KEY-FILE Filepath containing istio private key for mTLS (i.e. adapter.key). --istio-certificate-file=ISTIO-CERTIFICATE-FILE Filepath containing istio certificate for mTLS (i.e. ca.pem). --telemetry-service=TELEMETRY-SERVICE Service that is used for telemetry [Prometheus, ApplicationInsights] --instrumentation-key=INSTRUMENTATION-KEY The ApplicationInsights-InstrumentationKey that is used to connect to the API. --application-insights-service-name=\"Kelon\" The name which will be displayed for kelon inside application insights. --application-insights-max-batch-size=8192 Configure how many items can be sent in one call to the data collector. --application-insights-max-batch-interval-seconds=2 Configure the maximum delay before sending queued telemetry. --application-insights-log-levels=\"fatal,panic,error,warn\" Configure log levels which are sent. Allowed values are [fatal, panic, error, warn, info, debug, trace] --application-insights-stats-interval-seconds=5 Interval in seconds in which system stats are measured and sent. --version Show application version. Commands: help [<command>...] Show help. run Run kelon in production mode. In addition to that Kelon provides the possibility to be configured via environment variables. This may be handy if you want to run it inside a container.","title":"Kelon (CLI)"},{"location":"operations/Configuration/#general","text":"Flag Short Environment Default Type --datastore-conf -d DATASTORE_CONF ./datastore.yml Existing File --api-conf -a API_CONF ./api.yml Existing File --config-watcher-path CONFIG_WATCHER_PATH ./policies Existing Dir --opa-conf -o OPA_CONF ./opa.yml Existing File --rego-dir -r REGO_DIR ./policies Existing Dir --path-prefix PATH_PREFIX /v1 String --port -p PORT 8181 Number --preprocess-policies PREPROCESS_POLICIES false Boolean --respond-with-status-code RESPOND_WITH_STATUS_CODE false Boolean","title":"General"},{"location":"operations/Configuration/#envoy","text":"Flag Short Environment Default Type --envoy-port ENVOY_PORT Number --envoy-dry-run ENVOY_DRY_RUN false Boolean --envoy-reflection ENVOY_REFLECTION false Boolean","title":"Envoy"},{"location":"operations/Configuration/#istio","text":"Flag Short Environment Default Type --istio-port ISTIO_PORT Number --istio-credential-file ISTIO_CREDENTIAL_FILE Existing File --istio-private-key-file ISTIO_PRIVATE_KEY_FILE Existing File --istio-certificate-file ISTIO_CERTIFICATE_FILE Existing File","title":"Istio"},{"location":"operations/Configuration/#telemetry","text":"Flag Short Environment Default Type --telemetry-service TELEMETRY_SERVICE Enum","title":"Telemetry"},{"location":"operations/Configuration/#application-insights","text":"When you have set ApplicationInsights as --telemetry-service Flag Short Environment Default Type --instrumentation-key INSTRUMENTATION_KEY String --application-insights-service-name APPLICATION_INSIGHTS_SERVICE_NAME Kelon String --application-insights-max-batch-size APPLICATION_INSIGHTS_MAX_BATCH_SIZE 8192 Number --application-insights-max-batch-interval-seconds APPLICATION_INSIGHTS_MAX_BATCH_INTERVAL_SECONDS 2 Number --application-insights-log-levels APPLICATION_INSIGHTS_LOG_LEVELS fatal,panic,error,warn Enum-List --application-insights-stats-interval-seconds APPLICATION_INSIGHTS_STATS_INTERVAL_SECONDS 5 Number","title":"Application Insights"},{"location":"operations/Configuration/#datastoreyml","text":"The datastore.yml defines all available datastores and their entities. # List of all datastores which kelon should be able to connect to # Each datastore has to have an entity schema configured! datastores : # Datastore's alias (it will be used throughout all your policies). mysql : # Datastore type # Kelon supports [mysql, postgres, mongo] [ type : <string> ] # Properties that are needed to connect to the datastore connection : # Hostname or IP of the database [ host : <string> ] # Port under which the database is available [ port : <int> ] # Name of the database to connect to # Many database servers run multiple databases. # In this case create one datastore for each database [ database : <string> ] # The user which is used for the database connection [ user : <string> ] # The password of the user [ password : <string> ] # Connection options for the database connection # To get all available options for your database, see section \"Connection options\" below [ <option> : <string> ] # Metadata attached to the datastore metadata : # Only used from SQL-Datastores # Sets max idle connections of the database connection pool [ maxIdleConnections : <int> ] # Only used from SQL-Datastores # Sets max open connections of the database connection pool [ maxOpenConnections : <int> ] # Only used from SQL-Datastores # Sets max lifetime of each connection inside the database connection pool [ connectionMaxLifetimeSeconds : <int> ] # Only used if ApplicationInsights is set as Telemetry-Service! # Sets the name of the Dependency which is traced for this datastore [ telemetryName : <string> ] # Only used if ApplicationInsights is set as Telemetry-Service! # Sets the type of the Dependency which is traced for this datastore [ telemetryType : <string> ] # Entity-Schemas define the entities of one schema inside a datastore. # An entity_schema has several purposes: # => Help kelon to detect misspellings in regos # => Create entity-aliases for complex table-names # => Define the structure of nested entities (Just for No-SQL DBs) entity_schemas : # Datastore's alias # This example shows how each SQL-Datastore should be configured. mysql : # Schema name # Kelon automatically adds the schema name to entities # This means that 'data.mysql.users' inside a rego will be translated # to 'appstore.users' in the resulting SQL-Statement. # # !!! The entities inside all schemas of one Datastore have to be disjunct !!! # Otherwise kelon will fail on startup appstore : # List of all entities of schema 'appstore' entities : # Entity with the name inside the datastore - [ name : <string> ] # And an optional alias (used inside regos) [ alias : <string> | optional ] # This example shows how each No-SQL-Datastore should be configured. mongo : # Schema name # Because No-SQL-Datastores don't have concept for schemas, # Kelon ignores the schema name for i.e. a MongoDB. # # !!! The entities inside all schemas of one Datastore have to be disjunct !!! # Otherwise kelon will fail on startup appstore : # List of all entities (in case of MongoDB each entity is a collection) entities : # Collection with it's name inside the datastore - [ name : <string> ] # Collection's optinal alias (used inside regos) [ alias : <string> | optional ] # Nested entities (Only supported for No-SQL-Datastores) # The depth of nesting entities is unlimited. # It makes no difference if the nested entities are arrays or objects entities : # Name of nested entity - [ name : <string> ] # Collection's optinal alias (used inside regos) [ alias : <string> | optional ]","title":"datastore.yml"},{"location":"operations/Configuration/#connection-options","text":"Kelon supports different databases (PostgreSQL, MySQL and MongoDB) each of them having different connection options. To keep the configuration of connection options as simple as possible, Kelon just passes all key-value-pairs of each the datastore connection (despite the dedicated ones like i.e. username, host, port, etc.) directly to the used database adapter. Following table should help to lookup all available options for each supported database: Database Used driver Options PostgreSQL github.com/lib/pq Go Docs, Connection String Parameters MySQL github.com/go-sql-driver/mysql Go Docs, DSN Parameters MongoDB go.mongodb.org/mongo-driver/mongo Mongo-Docs, Connection options","title":"Connection options"},{"location":"operations/Configuration/#injecting-environment-variables","text":"Each value inside the datastore.yml file can be replaced with a string follwing the pattern ${<environment variable>} which is replaced with the value of the environment variable at startup.","title":"Injecting environment variables"},{"location":"operations/Configuration/#call-operandsdatastore-typeyml","text":"Open Policy Agent has builtin call operands which may not be the same as the ones of each datastore. Therefore each datastore-type has to have a mapping-file inside the folder 'call-operands'. The name of each file inside this directory has to match the type of the datastore. # Call operands map OPA's functions to datastore-native ones. # You find more advanced files in directory /call-operands call-operands : # Operand name inside OPA's context - [ op : <string> ] # Number of arguments the function call should take # Used for validation [ args : <int> ] # Mapping which mappes the OPA-native call to a Datastore-native call. # This is done by defining a pattern where all occurences of $<arg-pos> # are replaced with the original argument at position <arg-pos> (zero based). [ mapping : <string> ]","title":"call-operands/{datastore-type}.yml"},{"location":"operations/Configuration/#apiyml","text":"The datastore.yml contains all necessary configuration kelon needs to map incoming api-requests to OPA-Queries executed inside datastores. # Mappings for the APIs that your services expose apis : # API-Collection # Each collection can have a path prefix which is prepended to every API-Mapping # inside the collection. - [ path-prefix : <URL|string> ] # All rego-queries mapped by this API-collection will include # this datastore-alias as unknown. # This means that the regos this collection targets can contain # something like 'data.<datastore-alias>.<entity>.<attribute>' [ datastore : <datastore-alias|string> ] # Path-Mappings for incoming paths # (the most specific mapping is picked in case of multiple mappings) mappings : # Path-Mapping # Each mapping has to specify a path (regex) and a package which is used # by kelon to generate the target package of an mapped query. - [ path : <regex|string> ] # OPA's target package of this Path-Mapping [ package : <string> ] # HTTP-Methods this path should map (optional) # If no methods are specified, kellon will match [GET,PUT,POST,DELETE,PATCH] methods : - [ <string> ... ]","title":"api.yml"},{"location":"operations/Configuration/#opayml","text":"Internally used by Open Policy Agent. Klick here for more information. labels : app : Kelon region : europe-west3 environment : development decision_logs : console : true reporting : min_delay_seconds : 300 max_delay_seconds : 600 default_decision : /http/authz/allow","title":"opa.yml"},{"location":"operations/Deployment/","text":"Deployment Besides using Kelon as Gateway with a proxy like Envoy or as plugin in a Service-Mesh, it can also be deployed standalone and integrated in your existing services with just a few lines of extra code. Local You can find more information on how to run Kelon as a standalone process here . Kubernetes Kelon can also be deployed into Kubernetes with only a few configurations which is also available here in our Kelon-Examples repository.","title":"Deployment"},{"location":"operations/Deployment/#deployment","text":"Besides using Kelon as Gateway with a proxy like Envoy or as plugin in a Service-Mesh, it can also be deployed standalone and integrated in your existing services with just a few lines of extra code.","title":"Deployment"},{"location":"operations/Deployment/#local","text":"You can find more information on how to run Kelon as a standalone process here .","title":"Local"},{"location":"operations/Deployment/#kubernetes","text":"Kelon can also be deployed into Kubernetes with only a few configurations which is also available here in our Kelon-Examples repository.","title":"Kubernetes"},{"location":"operations/Monitoring/","text":"Monitoring To keep you always in track of Kelon's current state, request/response statistics and many more performance metrics, Kelon provides two telemetry provider out of the box: Prometheus Application Insights by Microsoft One of them can be selected per running Kelon instance via the telemetry-service -flag. There are also more configuration options for each telemetry provider which you can finde in the Configuration section. Stats per telemetry provider Prometheus After enabling Prometheus as telemetry provider, Kelon exposes all collected metrics over the HTTP-Endpoint GET http://<host>:<port>/metrics Following metrics are currently provided for Prometheus Full system and Golang stats Full request stats HTTP GRPC (Proxied over HTTP internally) Database requests Errors (Currently only counter) Application Insights Application Insights has a push based model which is why there is no /metrics endpoint exposed when selecting Application Insights as telemetry provider. Instead you have to provide at least the instrumentation key from your previously created Application Insights Application from Azure-Portal. Afterwards Kelon pushes all available metrics into the Azure-Cloud on its own. Following metrics are currently provided for Application Insights Basic system stats % Processor Time Heap Memory Used % Heap Memory Used IO Data Bytes/sec Data In-Bytes/sec Data Out-Bytes/sec Full request stats HTTP GRPC (Proxied over HTTP internally) Database request (including queries) Dependency-Name/Type displayed in Azure's application overview can be configured via the datastore.yml here Errors (Including cause) End-to-End-tracking of all requests going into Kelon Entire log (Log levels can be configured here )","title":"Monitoring"},{"location":"operations/Monitoring/#monitoring","text":"To keep you always in track of Kelon's current state, request/response statistics and many more performance metrics, Kelon provides two telemetry provider out of the box: Prometheus Application Insights by Microsoft One of them can be selected per running Kelon instance via the telemetry-service -flag. There are also more configuration options for each telemetry provider which you can finde in the Configuration section.","title":"Monitoring"},{"location":"operations/Monitoring/#stats-per-telemetry-provider","text":"","title":"Stats per telemetry provider"},{"location":"operations/Monitoring/#prometheus","text":"After enabling Prometheus as telemetry provider, Kelon exposes all collected metrics over the HTTP-Endpoint GET http://<host>:<port>/metrics Following metrics are currently provided for Prometheus Full system and Golang stats Full request stats HTTP GRPC (Proxied over HTTP internally) Database requests Errors (Currently only counter)","title":"Prometheus"},{"location":"operations/Monitoring/#application-insights","text":"Application Insights has a push based model which is why there is no /metrics endpoint exposed when selecting Application Insights as telemetry provider. Instead you have to provide at least the instrumentation key from your previously created Application Insights Application from Azure-Portal. Afterwards Kelon pushes all available metrics into the Azure-Cloud on its own. Following metrics are currently provided for Application Insights Basic system stats % Processor Time Heap Memory Used % Heap Memory Used IO Data Bytes/sec Data In-Bytes/sec Data Out-Bytes/sec Full request stats HTTP GRPC (Proxied over HTTP internally) Database request (including queries) Dependency-Name/Type displayed in Azure's application overview can be configured via the datastore.yml here Errors (Including cause) End-to-End-tracking of all requests going into Kelon Entire log (Log levels can be configured here )","title":"Application Insights"},{"location":"operations/Security/","text":"Security","title":"Security"},{"location":"operations/Security/#security","text":"","title":"Security"}]}